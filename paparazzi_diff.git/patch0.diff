diff --git a/conf/airframes/juav_configuration/jUAV/ChimuLisaFw.xml b/conf/airframes/juav_configuration/jUAV/ChimuLisaFw.xml
new file mode 100644
index 0000000..ddbdeea
--- /dev/null
+++ b/conf/airframes/juav_configuration/jUAV/ChimuLisaFw.xml
@@ -0,0 +1,168 @@
+<!DOCTYPE airframe SYSTEM "../../airframe.dtd">
+
+<!-- Microjet Multiplex (http://www.multiplex-rc.de/)
+     Tiny 1.1 board (http://paparazzi.enac.fr/wiki/Tiny)
+     Tilted infrared sensor
+     Xbee modem in API mode
+-->
+
+<airframe name="Microjet Tiny 1.1">
+
+  <servos>
+    <servo name="MOTOR"         no="0" min="1290" neutral="1290" max="1810"/>
+    <servo name="AILEVON_LEFT"  no="1" min="2000" neutral="1510" max="1000"/>
+    <servo name="AILEVON_RIGHT" no="2" min="1000" neutral="1535" max="2000"/>
+  </servos>
+
+  <commands>
+    <axis name="THROTTLE" failsafe_value="0"/>
+    <axis name="ROLL"     failsafe_value="0"/>
+    <axis name="PITCH"    failsafe_value="0"/>
+  </commands>
+
+  <rc_commands>
+    <set command="THROTTLE" value="@THROTTLE"/>
+    <set command="ROLL"     value="@ROLL"/>
+    <set command="PITCH"    value="@PITCH"/>
+  </rc_commands>
+
+  <section name="MIXER">
+    <define name="AILEVON_AILERON_RATE" value="0.75"/>
+    <define name="AILEVON_ELEVATOR_RATE" value="0.75"/>
+  </section>
+
+  <command_laws>
+    <let var="aileron"  value="@ROLL  * AILEVON_AILERON_RATE"/>
+    <let var="elevator" value="@PITCH * AILEVON_ELEVATOR_RATE"/>
+    <set servo="MOTOR"         value="@THROTTLE"/>
+    <set servo="AILEVON_LEFT"  value="$elevator + $aileron"/>
+    <set servo="AILEVON_RIGHT" value="$elevator - $aileron"/>
+  </command_laws>
+
+  <section name="AUTO1" prefix="AUTO1_">
+    <define name="MAX_ROLL" value="0.7"/>
+    <define name="MAX_PITCH" value="0.6"/>
+  </section>
+
+  <section name="BAT">
+    <define name="MILLIAMP_AT_FULL_THROTTLE" value="2000"/>
+
+    <define name="CATASTROPHIC_BAT_LEVEL" value="9.3" unit="V"/>
+  </section>
+
+  <section name="MISC">
+    <define name="NOMINAL_AIRSPEED" value="13." unit="m/s"/>
+    <define name="CARROT" value="5." unit="s"/>
+    <define name="KILL_MODE_DISTANCE" value="(1.5*MAX_DIST_FROM_HOME)"/>
+    <define name="CONTROL_FREQUENCY" value="60" unit="Hz"/>
+    <define name="XBEE_INIT" value="&quot;ATPL2\rATRN5\rATTT80\r&quot;"/>
+<!--    <define name="NO_XBEE_API_INIT" value="TRUE"/> -->
+
+    <define name="DEFAULT_CIRCLE_RADIUS" value="80."/>
+
+  </section>
+
+  <section name="VERTICAL CONTROL" prefix="V_CTL_">
+    <define name="POWER_CTL_BAT_NOMINAL" value="11.1" unit="volt"/>
+    <!-- outer loop proportional gain -->
+    <define name="ALTITUDE_PGAIN" value="0.03"/>
+    <!-- outer loop saturation -->
+    <define name="ALTITUDE_MAX_CLIMB" value="2."/>
+
+    <!-- auto throttle inner loop -->
+    <define name="AUTO_THROTTLE_NOMINAL_CRUISE_THROTTLE" value="0.32"/>
+    <define name="AUTO_THROTTLE_MIN_CRUISE_THROTTLE" value="0.25"/>
+    <define name="AUTO_THROTTLE_MAX_CRUISE_THROTTLE" value="0.65"/>
+    <define name="AUTO_THROTTLE_LOITER_TRIM" value="1500"/>
+    <define name="AUTO_THROTTLE_DASH_TRIM" value="-4000"/>
+    <define name="AUTO_THROTTLE_CLIMB_THROTTLE_INCREMENT" value="0.15" unit="%/(m/s)"/>
+    <define name="AUTO_THROTTLE_PGAIN" value="0.01"/>
+    <define name="AUTO_THROTTLE_IGAIN" value="0.1"/>
+    <define name="AUTO_THROTTLE_PITCH_OF_VZ_PGAIN" value="0.05"/>
+
+    <define name="THROTTLE_SLEW_LIMITER" value="2" unit="s"/>
+  </section>
+
+  <section name="HORIZONTAL CONTROL" prefix="H_CTL_">
+    <define name="COURSE_PGAIN" value="1.4"/>
+
+    <define name="ROLL_MAX_SETPOINT" value="0.6" unit="rad"/>
+    <define name="PITCH_MAX_SETPOINT" value="0.5" unit="rad"/>
+    <define name="PITCH_MIN_SETPOINT" value="-0.5" unit="rad"/>
+
+    <define name="PITCH_PGAIN" value="12000."/>
+    <define name="PITCH_DGAIN" value="1.5"/>
+
+    <define name="ELEVATOR_OF_ROLL" value="1250"/>
+
+    <define name="ROLL_SLEW" value="0.1"/>
+
+    <define name="ROLL_ATTITUDE_GAIN" value="7500"/>
+    <define name="ROLL_RATE_GAIN" value="1500"/>
+  </section>
+
+  <section name="AGGRESSIVE" prefix="AGR_">
+    <define name="BLEND_START" value="20"/><!-- Altitude Error to Initiate Aggressive Climb CANNOT BE ZERO!!-->
+    <define name="BLEND_END" value="10"/><!-- Altitude Error to Blend Aggressive to Regular Climb Modes  CANNOT BE ZERO!!-->
+    <define name="CLIMB_THROTTLE" value="1.00"/><!-- Gaz for Aggressive Climb -->
+    <define name="CLIMB_PITCH" value="0.3"/><!-- Pitch for Aggressive Climb -->
+    <define name="DESCENT_THROTTLE" value="0.1"/><!-- Gaz for Aggressive Decent -->
+    <define name="DESCENT_PITCH" value="-0.25"/><!-- Pitch for Aggressive Decent -->
+    <define name="CLIMB_NAV_RATIO" value="0.8"/><!-- Percent Navigation for Altitude Error Equal to Start Altitude -->
+    <define name="DESCENT_NAV_RATIO" value="1.0"/>
+    </section>
+
+  <section name="FAILSAFE" prefix="FAILSAFE_">
+    <define name="DELAY_WITHOUT_GPS" value="2" unit="s"/>
+    <define name="DEFAULT_THROTTLE" value="0.3" unit="%"/>
+    <define name="DEFAULT_ROLL" value="0.3" unit="rad"/>
+    <define name="DEFAULT_PITCH" value="0.5" unit="rad"/>
+  </section>
+
+  <section name="SIMU">
+    <define name="JSBSIM_MODEL" value="&quot;Malolo1&quot;"/>
+    <define name="JSBSIM_IR_ROLL_NEUTRAL" value="0." unit="deg"/>
+    <define name="JSBSIM_IR_PITCH_NEUTRAL" value="0." unit="deg"/>
+  </section>
+
+  <section name="INS" prefix="INS_">
+    <define name="ROLL_NEUTRAL_DEFAULT" value="0" unit="deg"/>
+    <define name="PITCH_NEUTRAL_DEFAULT" value="0" unit="deg"/>
+  </section>
+
+  <!--modules>
+    <load name="ins_chimu_uart.xml">
+      <configure name="CHIMU_UART_NR" value="3"/>
+    </load>
+  </modules-->
+
+  <firmware name="fixedwing">
+    <target name="ap"     		board="lisa_l_1.0"/>
+    <target name="sim" 			board="pc" />
+    <target name="jsbsim"       board="pc"/>
+
+    <define name="AGR_CLIMB" />
+    <define name="LOITER_TRIM" />
+
+    <subsystem name="radio_control" type="ppm"/>
+
+    <!-- Communication -->
+    <subsystem name="telemetry" 	type="transparent">
+      <configure name="MODEM_BAUD" 		value="B9600"/>
+    </subsystem>
+
+    <subsystem name="control"/>
+    <!-- Sensors -->
+    <subsystem name="gps" 		    type="ublox_utm"/>
+    <subsystem name="navigation"/>
+  </firmware>
+
+
+  <firmware name="setup">
+    <target name="tunnel"           board="tiny_1.1" />
+    <target name="usb_tunnel_0"     board="tiny_1.1" />
+    <target name="usb_tunnel_1"     board="tiny_1.1" />
+    <target name="setup_actuators"  board="tiny_1.1" />
+  </firmware>
+
+</airframe>
diff --git a/conf/airframes/juav_configuration/jUAV/jsbsim.xml b/conf/airframes/juav_configuration/jUAV/jsbsim.xml
new file mode 100644
index 0000000..20410dd
--- /dev/null
+++ b/conf/airframes/juav_configuration/jUAV/jsbsim.xml
@@ -0,0 +1,228 @@
+<!DOCTYPE airframe SYSTEM "../../airframe.dtd">
+
+<!-- Funjet Multiplex (http://www.multiplex-rc.de/)
+     Tiny 2.1 board (http://paparazzi.enac.fr/wiki/index.php/Tiny_v2)
+     Tilted infrared sensor (http://paparazzi.enac.fr/wiki/index.php/Image:Tiny_v2_1_Funjet.jpg)
+     Radiotronix modem
+-->
+
+<airframe name="Funjet 1 Tiny 2.1">
+
+<!-- commands section -->
+  <servos>
+    <servo name="MOTOR"         no="0" min="1000" neutral="1000" max="2000"/>
+    <servo name="AILEVON_LEFT"  no="2" min="1130" neutral="1500" max="1880"/>
+    <servo name="AILEVON_RIGHT" no="6" min="1980" neutral="1515" max="1170"/>
+  </servos>
+
+  <commands>
+    <axis name="THROTTLE" failsafe_value="0"/>
+    <axis name="ROLL"     failsafe_value="0"/>
+    <axis name="PITCH"    failsafe_value="0"/>
+  </commands>
+
+  <rc_commands>
+    <set command="THROTTLE" value="@THROTTLE"/>
+    <set command="ROLL"     value="@ROLL"/>
+    <set command="PITCH"    value="@PITCH"/>
+  </rc_commands>
+
+  <section name="MIXER">
+    <define name="AILEVON_AILERON_RATE" value="0.75"/>
+    <define name="AILEVON_ELEVATOR_RATE" value="0.75"/>
+  </section>
+
+  <command_laws>
+    <let var="aileron"  value="@ROLL  * AILEVON_AILERON_RATE"/>
+    <let var="elevator" value="@PITCH * AILEVON_ELEVATOR_RATE"/>
+    <set servo="MOTOR"           value="@THROTTLE"/>
+    <set servo="AILEVON_LEFT"  value="$elevator + $aileron"/>
+    <set servo="AILEVON_RIGHT" value="$elevator - $aileron"/>
+  </command_laws>
+
+  <section name="AUTO1" prefix="AUTO1_">
+    <define name="MAX_ROLL" value="0.85"/>
+    <define name="MAX_PITCH" value="0.6"/>
+  </section>
+
+  <section name="adc" prefix="ADC_CHANNEL_">
+    <define name="IR1" value="ADC_1"/>
+    <define name="IR2" value="ADC_2"/>
+    <define name="IR_TOP" value="ADC_0"/>
+    <define name="IR_NB_SAMPLES" value="16"/>
+  </section>
+
+  <section name="INFRARED" prefix="IR_">
+    <define name="ADC_IR1_NEUTRAL" value="512"/>
+    <define name="ADC_IR2_NEUTRAL" value="512"/>
+    <define name="ADC_TOP_NEUTRAL" value="512"/>
+
+    <define name="LATERAL_CORRECTION" value="1."/>
+    <define name="LONGITUDINAL_CORRECTION" value="1."/>
+    <define name="VERTICAL_CORRECTION" value="1.5"/>
+
+    <define name="HORIZ_SENSOR_TILTED" value="1"/>
+    <define name="IR2_SIGN" value="-1"/>
+    <define name="TOP_SIGN" value="-1"/>
+
+    <define name="ROLL_NEUTRAL_DEFAULT" value="-3.6" unit="deg"/>
+    <define name="PITCH_NEUTRAL_DEFAULT" value="6" unit="deg"/>
+
+    <define name="CORRECTION_UP" value="1."/>
+    <define name="CORRECTION_DOWN" value="1."/>
+    <define name="CORRECTION_LEFT" value="1."/>
+    <define name="CORRECTION_RIGHT" value="1."/>
+  </section>
+
+  <section name="IMU" prefix="IMU_">
+    <define name="GYRO_P_SIGN"  value="-1."/>
+    <define name="GYRO_P_NEUTRAL" value="512"/>
+    <define name="GYRO_P_SENS" value="1." integer="16"/>
+  </section>
+
+  <section name="BAT">
+    <define name="MILLIAMP_AT_FULL_THROTTLE" value="2000"/>
+
+    <define name="CATASTROPHIC_BAT_LEVEL" value="9.3" unit="V"/>
+  </section>
+
+  <section name="MISC">
+    <define name="NOMINAL_AIRSPEED" value="17." unit="m/s"/>
+    <define name="CARROT" value="5." unit="s"/>
+    <define name="KILL_MODE_DISTANCE" value="(1.5*MAX_DIST_FROM_HOME)"/>
+    <define name="CONTROL_FREQUENCY" value="120" unit="Hz"/>
+<!--    <define name="XBEE_INIT" value="\"ATPL2\rATRN1\rATTT80\r\""/> -->
+<!--    <define name="NO_XBEE_API_INIT" value="TRUE"/> -->
+
+    <define name="TRIGGER_DELAY" value="1."/>
+    <define name="DEFAULT_CIRCLE_RADIUS" value="80."/>
+  </section>
+
+  <section name="VERTICAL CONTROL" prefix="V_CTL_">
+
+    <define name="POWER_CTL_BAT_NOMINAL" value="11.1" unit="volt"/>
+    <!-- outer loop proportional gain -->
+    <define name="ALTITUDE_PGAIN" value="0.04"/>
+    <!-- outer loop saturation -->
+    <define name="ALTITUDE_MAX_CLIMB" value="2."/>
+
+    <!-- auto throttle inner loop -->
+    <define name="AUTO_THROTTLE_NOMINAL_CRUISE_THROTTLE" value="0.35"/>
+    <define name="AUTO_THROTTLE_MIN_CRUISE_THROTTLE" value="0.3"/>
+    <define name="AUTO_THROTTLE_MAX_CRUISE_THROTTLE" value="0.80"/>
+    <define name="AUTO_THROTTLE_LOITER_TRIM" value="1500"/>
+    <define name="AUTO_THROTTLE_DASH_TRIM" value="-1000"/>
+    <define name="AUTO_THROTTLE_CLIMB_THROTTLE_INCREMENT" value="0.3" unit="%/(m/s)"/>
+    <define name="AUTO_THROTTLE_PGAIN" value="0.02"/>
+    <define name="AUTO_THROTTLE_IGAIN" value="0.1"/>
+    <define name="AUTO_THROTTLE_PITCH_OF_VZ_PGAIN" value="0.1"/>
+
+    <!-- auto pitch inner loop -->
+    <define name="AUTO_PITCH_PGAIN" value="0.05"/>
+    <define name="AUTO_PITCH_IGAIN" value="0.075"/>
+    <define name="AUTO_PITCH_MAX_PITCH" value="0.35"/>
+    <define name="AUTO_PITCH_MIN_PITCH" value="-0.35"/>
+
+   <define name="THROTTLE_SLEW" value="0.5"/>
+
+  </section>
+
+  <section name="HORIZONTAL CONTROL" prefix="H_CTL_">
+    <define name="COURSE_PGAIN" value="1."/>
+
+    <define name="ROLL_MAX_SETPOINT" value="0.7" unit="rad"/>
+    <define name="PITCH_MAX_SETPOINT" value="0.5" unit="rad"/>
+    <define name="PITCH_MIN_SETPOINT" value="-0.5" unit="rad"/>
+
+    <define name="PITCH_PGAIN" value="10000."/>
+    <define name="PITCH_DGAIN" value="1.5"/>
+
+    <define name="ELEVATOR_OF_ROLL" value="2500"/>
+
+    <define name="ROLL_ATTITUDE_GAIN" value="7500"/>
+    <define name="ROLL_RATE_GAIN" value="1500"/>
+  </section>
+
+  <section name="NAV">
+    <define name="NAV_GLIDE_PITCH_TRIM" value="0"/>
+    <define name="NAV_CROSS_TRACK_ERROR_IGAIN" value="0.05"/>
+    <define name="NAV_CROSS_TRACK_ERROR_MAX" value="10." unit="deg"/>
+  </section>
+
+  <section name="AGGRESSIVE" prefix="AGR_">
+    <define name="BLEND_START" value="20"/><!-- Altitude Error to Initiate Aggressive Climb CANNOT BE ZERO!!-->
+    <define name="BLEND_END" value="10"/><!-- Altitude Error to Blend Aggressive to Regular Climb Modes  CANNOT BE ZERO!!-->
+    <define name="CLIMB_THROTTLE" value="0.7"/><!-- Gaz for Aggressive Climb -->
+    <define name="CLIMB_PITCH" value="0.25"/><!-- Pitch for Aggressive Climb -->
+    <define name="DESCENT_THROTTLE" value="0.1"/><!-- Gaz for Aggressive Decent -->
+    <define name="DESCENT_PITCH" value="-0.15"/><!-- Pitch for Aggressive Decent -->
+    <define name="CLIMB_NAV_RATIO" value="0.8"/><!-- Percent Navigation for Altitude Error Equal to Start Altitude -->
+    <define name="DESCENT_NAV_RATIO" value="1.0"/>
+    </section>
+
+
+  <section name="GYRO_GAINS">
+    <define name="GYRO_MAX_RATE" value="200."/>
+    <define name="ROLLRATESUM_NB_SAMPLES" value="64"/>
+    <define name="ALT_ROLL__PGAIN" value="1.0"/>
+    <define name="ROLL_RATE_PGAIN" value="1000.0"/>
+    <define name="ROLL_RATE_IGAIN" value="0.0"/>
+    <define name="ROLL_RATE_DGAIN" value="0.0"/>
+  </section>
+
+  <section name="FAILSAFE" prefix="FAILSAFE_">
+    <define name="DELAY_WITHOUT_GPS" value="1" unit="s"/>
+    <define name="DEFAULT_THROTTLE" value="0.3" unit="%"/>
+    <define name="DEFAULT_ROLL" value="0.3" unit="rad"/>
+    <define name="DEFAULT_PITCH" value="0.5" unit="rad"/>
+    <define name="HOME_RADIUS" value="100" unit="m"/>
+  </section>
+
+  <section name="SIMU">
+    <define name="JSBSIM_MODEL" value="&quot;Malolo1&quot;"/>
+    <define name="JSBSIM_INIT"	value="&quot;Malolo1-IC&quot;"/>
+    <define name="JSBSIM_LAUNCHSPEED"	value="15.0"/>
+    <define name="JSBSIM_IR_ROLL_NEUTRAL" value="0." unit="deg"/>
+    <define name="JSBSIM_IR_PITCH_NEUTRAL" value="0." unit="deg"/>
+  </section>
+
+  <firmware name="fixedwing">
+    <target name="sim" 			board="pc" />
+    <target name="jsbsim" 	    board="pc"/>
+    <target name="ap" 			board="tiny_2.1"/>
+
+    <define name="AGR_CLIMB" />
+    <define name="LOITER_TRIM" />
+
+    <subsystem name="radio_control" type="ppm"/>
+
+    <!-- Communication -->
+    <subsystem name="telemetry" 	type="transparent">
+      <configure name="MODEM_BAUD" 		value="B9600"/>
+    </subsystem>
+
+    <subsystem name="control"/>
+    <!-- Sensors -->
+    <subsystem name="imu"       type="analog">
+      <configure name="GYRO_P" value="ADC_3"/>
+    </subsystem>
+    <subsystem name="ahrs" 		type="infrared"/>
+    <subsystem name="gps" 		    type="ublox_utm"/>
+    <subsystem name="navigation"/>
+    <subsystem name="ins" type="alt_float"/>
+
+  </firmware>
+
+  <modules>
+    <load name="infrared_adc.xml"/>
+  </modules>
+
+  <firmware name="setup">
+    <target name="tunnel"           board="tiny_2.1" />
+    <target name="usb_tunnel_0"     board="tiny_2.1" />
+    <target name="usb_tunnel_1"     board="tiny_2.1" />
+    <target name="setup_actuators"  board="tiny_2.1" />
+    <target name="tunnel" board="twog_1.0"/>
+  </firmware>
+
+</airframe>
diff --git a/conf/airframes/juav_configuration/jUAV/malolo_sim.xml b/conf/airframes/juav_configuration/jUAV/malolo_sim.xml
new file mode 100644
index 0000000..862226e
--- /dev/null
+++ b/conf/airframes/juav_configuration/jUAV/malolo_sim.xml
@@ -0,0 +1,241 @@
+<!DOCTYPE airframe SYSTEM "../../airframe.dtd">
+
+<!-- Funjet Multiplex (http://www.multiplex-rc.de/)
+     Tiny 2.1 board (http://paparazzi.enac.fr/wiki/index.php/Tiny_v2)
+     Tilted infrared sensor (http://paparazzi.enac.fr/wiki/index.php/Image:Tiny_v2_1_Funjet.jpg)
+     Radiotronix modem
+-->
+
+<airframe name="JSBSim test file (from funjet file)">
+
+<!-- commands section -->
+  <servos>
+    <servo name="MOTOR"         no="0" min="1000" neutral="1000" max="2000"/>
+    <servo name="AILEVON_LEFT"  no="2" min="1130" neutral="1500" max="1880"/>
+    <servo name="AILEVON_RIGHT" no="6" min="1980" neutral="1515" max="1170"/>
+  </servos>
+
+  <commands>
+    <axis name="THROTTLE" failsafe_value="0"/>
+    <axis name="ROLL"     failsafe_value="0"/>
+    <axis name="PITCH"    failsafe_value="0"/>
+  </commands>
+
+  <rc_commands>
+    <set command="THROTTLE" value="@THROTTLE"/>
+    <set command="ROLL"     value="@ROLL"/>
+    <set command="PITCH"    value="@PITCH"/>
+  </rc_commands>
+
+  <section name="MIXER">
+    <define name="AILEVON_AILERON_RATE" value="0.75"/>
+    <define name="AILEVON_ELEVATOR_RATE" value="0.75"/>
+  </section>
+
+  <command_laws>
+    <let var="aileron"  value="@ROLL  * AILEVON_AILERON_RATE"/>
+    <let var="elevator" value="@PITCH * AILEVON_ELEVATOR_RATE"/>
+    <set servo="MOTOR"           value="@THROTTLE"/>
+    <set servo="AILEVON_LEFT"  value="$elevator + $aileron"/>
+    <set servo="AILEVON_RIGHT" value="$elevator - $aileron"/>
+  </command_laws>
+
+  <section name="AUTO1" prefix="AUTO1_">
+    <define name="MAX_ROLL" value="0.85"/>
+    <define name="MAX_PITCH" value="0.6"/>
+  </section>
+
+  <section name="adc" prefix="ADC_CHANNEL_">
+    <define name="IR1" value="ADC_1"/>
+    <define name="IR2" value="ADC_2"/>
+    <define name="IR_TOP" value="ADC_0"/>
+    <define name="IR_NB_SAMPLES" value="16"/>
+
+    <define name="GYRO_ROLL" value="ADC_3"/>
+    <define name="GYRO_NB_SAMPLES" value="16"/>
+
+  </section>
+
+  <section name="INFRARED" prefix="IR_">
+    <define name="ADC_IR1_NEUTRAL" value="512"/>
+    <define name="ADC_IR2_NEUTRAL" value="512"/>
+    <define name="ADC_TOP_NEUTRAL" value="512"/>
+
+    <define name="LATERAL_CORRECTION" value="1."/>
+    <define name="LONGITUDINAL_CORRECTION" value="1."/>
+    <define name="VERTICAL_CORRECTION" value="1.5"/>
+
+    <define name="HORIZ_SENSOR_TILTED" value="1"/>
+    <define name="IR2_SIGN" value="-1"/>
+    <define name="TOP_SIGN" value="-1"/>
+
+    <define name="ROLL_NEUTRAL_DEFAULT" value="-3.6" unit="deg"/>
+    <define name="PITCH_NEUTRAL_DEFAULT" value="6" unit="deg"/>
+
+    <define name="CORRECTION_UP" value="1."/>
+    <define name="CORRECTION_DOWN" value="1."/>
+    <define name="CORRECTION_LEFT" value="1."/>
+    <define name="CORRECTION_RIGHT" value="1."/>
+  </section>
+
+ <section name="GYRO" prefix="GYRO_">
+    <define name="ADC_ROLL_NEUTRAL" value="520"/>
+    <define name="ADC_TEMP_NEUTRAL" value="476"/>
+    <define name="ADC_TEMP_SLOPE" value="0"/>
+    <define name="DYNAMIC_RANGE" value="300" unit="deg/s"/>
+    <define name="ADXRS300_RESISTOR_BRIDGE" value="(3.3/(3.3+1.8))"/>
+    <define name="ADXRS300_SENSITIVITY" value="5" unit="mV/(deg/s)"/>
+    <define name="ROLL_SCALE" value="3.3*1000./1024./(GYRO_ADXRS300_SENSITIVITY*GYRO_ADXRS300_RESISTOR_BRIDGE)" unit="deg/s/adc_unit"/>
+    <define name="ROLL_DIRECTION" value="-1."/>
+  </section>
+
+  <section name="BAT">
+    <define name="MILLIAMP_PER_PERCENT" value="0.86"/>
+
+    <define name="CATASTROPHIC_BAT_LEVEL" value="9.3" unit="V"/>
+  </section>
+
+  <section name="MISC">
+    <define name="NOMINAL_AIRSPEED" value="17." unit="m/s"/>
+    <define name="CARROT" value="5." unit="s"/>
+    <define name="KILL_MODE_DISTANCE" value="(1.5*MAX_DIST_FROM_HOME)"/>
+    <define name="CONTROL_FREQUENCY" value="60" unit="Hz"/>
+<!--    <define name="XBEE_INIT" value="\"ATPL2\rATRN1\rATTT80\r\""/> -->
+<!--    <define name="NO_XBEE_API_INIT" value="TRUE"/> -->
+    <define name="ALT_KALMAN_ENABLED" value="TRUE"/>
+
+    <define name="TRIGGER_DELAY" value="1."/>
+    <define name="DEFAULT_CIRCLE_RADIUS" value="80."/>
+  </section>
+
+  <section name="VERTICAL CONTROL" prefix="V_CTL_">
+
+    <define name="POWER_CTL_BAT_NOMINAL" value="11.1" unit="volt"/>
+    <!-- outer loop proportional gain -->
+    <define name="ALTITUDE_PGAIN" value="0.04"/>
+    <!-- outer loop saturation -->
+    <define name="ALTITUDE_MAX_CLIMB" value="2."/>
+
+    <!-- auto throttle inner loop -->
+    <define name="AUTO_THROTTLE_NOMINAL_CRUISE_THROTTLE" value="0.35"/>
+    <define name="AUTO_THROTTLE_MIN_CRUISE_THROTTLE" value="0.3"/>
+    <define name="AUTO_THROTTLE_MAX_CRUISE_THROTTLE" value="0.80"/>
+    <define name="AUTO_THROTTLE_LOITER_TRIM" value="1500"/>
+    <define name="AUTO_THROTTLE_DASH_TRIM" value="-1000"/>
+    <define name="AUTO_THROTTLE_CLIMB_THROTTLE_INCREMENT" value="0.1" unit="%/(m/s)"/>
+    <define name="AUTO_THROTTLE_PGAIN" value="0.02"/>
+    <define name="AUTO_THROTTLE_IGAIN" value="0.1"/>
+    <define name="AUTO_THROTTLE_PITCH_OF_VZ_PGAIN" value="0.1"/>
+
+    <!-- auto pitch inner loop -->
+    <define name="AUTO_PITCH_PGAIN" value="0.05"/>
+    <define name="AUTO_PITCH_IGAIN" value="0.075"/>
+    <define name="AUTO_PITCH_MAX_PITCH" value="0.35"/>
+    <define name="AUTO_PITCH_MIN_PITCH" value="-0.35"/>
+
+   <define name="THROTTLE_SLEW" value="0.5"/>
+
+  </section>
+
+  <section name="HORIZONTAL CONTROL" prefix="H_CTL_">
+    <define name="COURSE_PGAIN" value="1."/>
+
+    <define name="ROLL_MAX_SETPOINT" value="0.7" unit="rad"/>
+    <define name="PITCH_MAX_SETPOINT" value="0.5" unit="rad"/>
+    <define name="PITCH_MIN_SETPOINT" value="-0.5" unit="rad"/>
+
+    <define name="PITCH_PGAIN" value="10000."/>
+    <define name="PITCH_DGAIN" value="1.5"/>
+
+    <define name="ELEVATOR_OF_ROLL" value="2500"/>
+
+    <define name="ROLL_ATTITUDE_GAIN" value="7500"/>
+    <define name="ROLL_RATE_GAIN" value="1500"/>
+  </section>
+
+  <section name="NAV">
+    <define name="NAV_GLIDE_PITCH_TRIM" value="0"/>
+    <define name="NAV_CROSS_TRACK_ERROR_IGAIN" value="0.05"/>
+    <define name="NAV_CROSS_TRACK_ERROR_MAX" value="10." unit="deg"/>
+  </section>
+
+  <section name="AGGRESSIVE" prefix="AGR_">
+    <define name="BLEND_START" value="20"/><!-- Altitude Error to Initiate Aggressive Climb CANNOT BE ZERO!!-->
+    <define name="BLEND_END" value="10"/><!-- Altitude Error to Blend Aggressive to Regular Climb Modes  CANNOT BE ZERO!!-->
+    <define name="CLIMB_THROTTLE" value="0.7"/><!-- Gaz for Aggressive Climb -->
+    <define name="CLIMB_PITCH" value="0.25"/><!-- Pitch for Aggressive Climb -->
+    <define name="DESCENT_THROTTLE" value="0.1"/><!-- Gaz for Aggressive Decent -->
+    <define name="DESCENT_PITCH" value="-0.15"/><!-- Pitch for Aggressive Decent -->
+    <define name="CLIMB_NAV_RATIO" value="0.8"/><!-- Percent Navigation for Altitude Error Equal to Start Altitude -->
+    <define name="DESCENT_NAV_RATIO" value="1.0"/>
+    </section>
+
+
+  <section name="GYRO_GAINS">
+    <define name="GYRO_MAX_RATE" value="200."/>
+    <define name="ROLLRATESUM_NB_SAMPLES" value="64"/>
+    <define name="ALT_ROLL__PGAIN" value="1.0"/>
+    <define name="ROLL_RATE_PGAIN" value="1000.0"/>
+    <define name="ROLL_RATE_IGAIN" value="0.0"/>
+    <define name="ROLL_RATE_DGAIN" value="0.0"/>
+  </section>
+
+  <section name="FAILSAFE" prefix="FAILSAFE_">
+	<define name="DELAY_WITHOUT_GPS" value="1" unit="s"/>
+	<define name="DEFAULT_THROTTLE" value="0.3" unit="%"/>
+	<define name="DEFAULT_ROLL" value="0.3" unit="rad"/>
+	<define name="DEFAULT_PITCH" value="0.5" unit="rad"/>
+	<define name="HOME_RADIUS" value="100" unit="m"/>
+</section>
+
+<!--
+ <section name="DATALINK" prefix="DATALINK_">
+    <define name="DEVICE_TYPE" value="XBEE"/>
+    <define name="DEVICE_ADDRESS" value="...."/>
+  </section>
+-->
+
+  <section name="Digital camera telecommand">
+    <!-- IOs are seen as LEDs -->
+
+    <define name="LED_6_BANK" value="0"/>
+    <define name="LED_6_PIN" value="2"/> <!-- I2C SCL -->
+
+    <!-- ADC 5 -->
+    <define name="LED_7_BANK" value="0"/>
+    <define name="LED_7_PIN" value="3"/> <!-- I2C SDA -->
+
+    <define name="DC_SHUTTER_LED" value="6"/> <!-- Grey wire -->
+    <define name="DC_ZOOM_LED" value="7"/>
+  </section>
+
+  <section name="SIMU">
+    <define name="JSBSIM_MODEL" value="\"Malolo1\""/>
+ </section>
+
+ <makefile>
+CONFIG = \"tiny_2_1.h\"
+
+include $(PAPARAZZI_SRC)/conf/firmwares/tiny.makefile
+
+
+# Config for SITL simulation with JSBSim
+SIM_TYPE = JSBSIM
+sim.ARCHDIR = $(ARCHI)
+
+sim.CFLAGS += -I$(SIMDIR) -I/home/cocoleon/usr/include/JSBSim -I/usr/include
+sim.CFLAGS += `pkg-config glib-2.0 --cflags`
+sim.LDFLAGS += `pkg-config glib-2.0 --libs` -lm -lpcre -lglibivy -L/home/cocoleon/usr/lib/ -lJSBSim
+
+sim.CFLAGS += -DBOARD_CONFIG=\"tiny.h\" -DAGR_CLIMB -DLOITER_TRIM -DALT_KALMAN
+
+sim.CFLAGS += -DSITL -DAP -DFBW -DRADIO_CONTROL -DINTER_MCU -DDOWNLINK -DDOWNLINK_TRANSPORT=IvyTransport -DUSE_INFRARED -DNAV
+
+sim.srcs = $(SRC_ARCH)/jsbsim_hw.c $(SRC_ARCH)/jsbsim_gps.c $(SRC_ARCH)/jsbsim_ir.c $(SRC_ARCH)/ivy_transport.c
+sim.srcs += latlong.c radio_control.c subsystems/datalink/downlink.c commands.c gps.c inter_mcu.c infrared.c fw_h_ctl.c fw_v_ctl.c subsystems/nav.c estimator.c sys_time.c main_fbw.c main_ap.c datalink.c
+sim.srcs += subsystems/navigation/nav_line.c subsystems/navigation/nav_survey_rectangle.c
+
+sim.srcs += $(SIMDIR)/sim_ac_jsbsim.c $(SIMDIR)/sim_ac_fw.c
+
+  </makefile>
+</airframe>
diff --git a/conf/airframes/juav_configuration/jUAV/mentor_tum.xml b/conf/airframes/juav_configuration/jUAV/mentor_tum.xml
new file mode 100644
index 0000000..b540c22
--- /dev/null
+++ b/conf/airframes/juav_configuration/jUAV/mentor_tum.xml
@@ -0,0 +1,215 @@
+<!DOCTYPE airframe SYSTEM "../../airframe.dtd">
+
+<!-- Mentor Multiplex (http://www.multiplex-rc.de/)
+     Twog v1 board (http://paparazzi.enac.fr/wiki/Twog_v1)
+     Tilted infrared sensor
+     XBee modem in transparent mode.
+     Radio PPM encoder
+-->
+
+<airframe name="Mentor Twog AkaModell">
+
+  <firmware name="fixedwing">
+    <target name="ap" 			board="twog_1.0"/>
+    <target name="sim" 			board="pc"/>
+    <target name="jsbsim" 		board="pc"/>
+
+    <define name="AGR_CLIMB"/>
+    <define name="LOITER_TRIM"/>
+    <define name="WIND_INFO"/>
+
+    <subsystem name="radio_control" type="ppm"/>
+    <!--<define name="TELEMETRY_MODE_FBW" value="1"/>-->
+    <subsystem name="telemetry" type="transparent"/>
+    <subsystem name="control"/>
+    <subsystem name="ahrs" type="infrared"/>
+    <subsystem name="gps" type="ublox"/>
+    <subsystem name="navigation"/>
+    <subsystem name="ins" type="alt_float"/>
+  </firmware>
+
+  <firmware name="setup">
+    <target name="tunnel"          board="twog_1.0" />
+    <target name="usb_tunnel_0"    board="twog_1.0" />
+  </firmware>
+
+  <modules main_freq="60">
+    <load name="servo_switch.xml">
+      <define name="SERVO_SWITCH_ON_VALUE"  value="1100"/>
+      <define name="SERVO_SWITCH_OFF_VALUE" value="1900"/>
+      <define name="SERVO_SWITCH_SERVO"     value="SERVO_SWITCH"/>
+    </load>
+    <load name="sys_mon.xml"/>
+    <load name="infrared_adc.xml"/>
+  </modules>
+
+<!-- commands section -->
+  <commands>
+    <axis name="THROTTLE" failsafe_value="0"/>
+    <axis name="ROLL" failsafe_value="0"/>
+    <axis name="PITCH" failsafe_value="0"/>
+    <axis name="YAW" failsafe_value="0"/>
+  </commands>
+
+  <servos>
+    <servo name="AILERON_RIGHT" no="0" min="1000" neutral="1500" max="2000"/>
+    <servo name="ELEVATOR" no="2" min="2000" neutral="1500" max="1000"/>
+    <servo name="THROTTLE" no="3" min="1000" neutral="1000" max="2000"/>
+    <servo name="RUDDER" no="4" min="2000" neutral="1500" max="1000"/>
+    <servo name="AILERON_LEFT" no="6" min="1000" neutral="1500" max="2000"/>
+    <servo name="SWITCH" no="7" min="1000" neutral="1500" max="2000"/>
+  </servos>
+
+  <rc_commands>
+    <set command="ROLL" value="@ROLL"/>
+    <set command="PITCH" value="@PITCH"/>
+    <set command="THROTTLE" value="@THROTTLE"/>
+    <set command="YAW" value="@YAW"/>
+  </rc_commands>
+
+  <auto_rc_commands>
+   <!-- <set command="YAW" value="@YAW"/> -->
+  </auto_rc_commands>
+
+  <section name="MIXER">
+     <define name="AILERON_DIFF" value="0.66"/>
+     <define name="COMBI_SWITCH" value="0.3"/>
+  </section>
+
+  <command_laws>
+    <set servo="THROTTLE" value="@THROTTLE"/>
+    <set servo="ELEVATOR" value="@PITCH"/>
+    <set servo="RUDDER" value="@YAW + @ROLL*COMBI_SWITCH"/>
+
+    <let var="roll" value="@ROLL"/>
+    <set servo="AILERON_LEFT" value="($roll > 0 ? AILERON_DIFF : 1) * $roll"/>
+    <set servo="AILERON_RIGHT" value="($roll > 0 ? 1 : AILERON_DIFF) * $roll"/>
+  </command_laws>
+
+
+  <section name="AUTO1" prefix="AUTO1_">
+    <define name="MAX_ROLL" value="55" unit="deg"/>
+    <define name="MAX_PITCH" value="35" unit="deg"/>
+  </section>
+
+
+  <section name="INFRARED" prefix="IR_">
+    <define name="ADC_IR1_NEUTRAL" value="511"/>
+    <define name="ADC_IR2_NEUTRAL" value="516"/>
+    <define name="ADC_TOP_NEUTRAL" value="512"/>
+
+    <define name="LATERAL_CORRECTION" value="0.35"/>
+    <define name="LONGITUDINAL_CORRECTION" value="0.35"/>
+    <define name="VERTICAL_CORRECTION" value="1.0"/>
+
+    <define name="HORIZ_SENSOR_TILTED" value="1"/>
+
+    <define name="IR1_SIGN" value="1"/>
+    <define name="IR2_SIGN" value="-1"/>
+    <define name="TOP_SIGN" value="-1"/>
+
+    <define name="ROLL_NEUTRAL_DEFAULT" value="0." unit="deg"/>
+    <define name="PITCH_NEUTRAL_DEFAULT" value="11.4591560364" unit="deg"/>
+
+    <define name="CORRECTION_UP" value="1."/>
+    <define name="CORRECTION_DOWN" value="1."/>
+    <define name="CORRECTION_LEFT" value="1."/>
+    <define name="CORRECTION_RIGHT" value="1."/>
+  </section>
+
+
+  <section name="BAT">
+    <define name="MILLIAMP_AT_FULL_THROTTLE" value="20000" unit="mA"/>
+    <define name="CATASTROPHIC_BAT_LEVEL" value="12" unit="V"/>
+    <define name="CRITIC_BAT_LEVEL" value="12.5" unit="V"/>
+    <define name="LOW_BAT_LEVEL" value="13.5" unit="V"/>
+    <define name="MAX_BAT_LEVEL" value="16" unit="V"/>
+  </section>
+
+  <section name="MISC">
+    <define name="MINIMUM_AIRSPEED" value="12." unit="m/s"/>
+    <define name="NOMINAL_AIRSPEED" value="15." unit="m/s"/>
+    <define name="MAXIMUM_AIRSPEED" value="20." unit="m/s"/>
+    <define name="CARROT" value="5." unit="s"/>
+    <define name="KILL_MODE_DISTANCE" value="(1.5*MAX_DIST_FROM_HOME)"/>
+    <define name="CONTROL_FREQUENCY" value="60" unit="Hz"/>
+    <define name="ALT_KALMAN_ENABLED" value="TRUE"/>
+
+    <define name="TRIGGER_DELAY" value="1."/>
+    <define name="DEFAULT_CIRCLE_RADIUS" value="100."/>
+  </section>
+
+  <section name="VERTICAL CONTROL" prefix="V_CTL_">
+    <define name="POWER_CTL_BAT_NOMINAL" value="14.8" unit="volt"/>
+    <!-- outer loop proportional gain -->
+    <define name="ALTITUDE_PGAIN" value="0.04" unit="(m/s)/m"/>
+    <!-- outer loop saturation -->
+    <define name="ALTITUDE_MAX_CLIMB" value="2.5" unit="m/s"/>
+
+    <!-- auto throttle inner loop -->
+    <define name="AUTO_THROTTLE_NOMINAL_CRUISE_THROTTLE" value="0.55" unit="%"/>
+    <define name="AUTO_THROTTLE_MIN_CRUISE_THROTTLE" value="0.30" unit="%"/>
+    <define name="AUTO_THROTTLE_MAX_CRUISE_THROTTLE" value="0.80" unit="%"/>
+    <define name="AUTO_THROTTLE_LOITER_TRIM" value="1500" unit="pprz_t"/>
+    <define name="AUTO_THROTTLE_DASH_TRIM" value="-1000" unit="pprz_t"/>
+    <define name="AUTO_THROTTLE_CLIMB_THROTTLE_INCREMENT" value="0.1" unit="%/(m/s)"/>
+    <define name="AUTO_THROTTLE_PGAIN" value="0.02"/>
+    <define name="AUTO_THROTTLE_IGAIN" value="0.1"/>
+    <define name="AUTO_THROTTLE_PITCH_OF_VZ_PGAIN" value="0.5" unit="rad/(m/s)"/>
+
+    <!-- auto pitch inner loop -->
+    <define name="AUTO_PITCH_PGAIN" value="0.05"/>
+    <define name="AUTO_PITCH_IGAIN" value="0.075"/>
+    <define name="AUTO_PITCH_MAX_PITCH" value="0.35" unit="rad"/>
+    <define name="AUTO_PITCH_MIN_PITCH" value="-0.35" unit="rad"/>
+
+   <define name="THROTTLE_SLEW" value="0.25"/>
+  </section>
+
+  <section name="HORIZONTAL CONTROL" prefix="H_CTL_">
+    <define name="COURSE_PGAIN" value="1.1"/>
+
+    <define name="ROLL_MAX_SETPOINT"  value="50" unit="deg"/>
+    <define name="PITCH_MAX_SETPOINT" value="30" unit="deg"/>
+    <define name="PITCH_MIN_SETPOINT" value="-25" unit="deg"/>
+
+    <define name="PITCH_PGAIN" value="7000."/>
+    <define name="PITCH_DGAIN" value="1.5"/>
+
+    <define name="AILERON_OF_THROTTLE" value="0.0"/>
+    <define name="ELEVATOR_OF_ROLL" value="1250"/>
+
+    <define name="ROLL_ATTITUDE_GAIN" value="7500."/>
+    <!-- <define name="ROLL_RATE_GAIN" value="1500"/> -->
+  </section>
+
+  <section name="NAV">
+    <define name="NAV_GLIDE_PITCH_TRIM" value="0"/>
+  </section>
+
+  <section name="AGGRESSIVE" prefix="AGR_">
+    <define name="BLEND_START" value="25"/><!-- Altitude Error to Initiate Aggressive Climb CANNOT BE ZERO!!-->
+    <define name="BLEND_END" value="10"/><!-- Altitude Error to Blend Aggressive to Regular Climb Modes  CANNOT BE ZERO!!-->
+    <define name="CLIMB_THROTTLE" value="0.8"/><!-- Gaz for Aggressive Climb -->
+    <define name="CLIMB_PITCH" value="0.3"/><!-- Pitch for Aggressive Climb -->
+    <define name="DESCENT_THROTTLE" value="0.1"/><!-- Gaz for Aggressive Decent -->
+    <define name="DESCENT_PITCH" value="-0.15"/><!-- Pitch for Aggressive Decent -->
+    <define name="CLIMB_NAV_RATIO" value="0.8"/><!-- Percent Navigation for Altitude Error Equal to Start Altitude -->
+    <define name="DESCENT_NAV_RATIO" value="1.0"/>
+    </section>
+
+  <section name="FAILSAFE" prefix="FAILSAFE_">
+    <define name="DELAY_WITHOUT_GPS" value="1" unit="s"/>
+    <define name="DEFAULT_THROTTLE" value="0.3" unit="%"/>
+    <define name="DEFAULT_ROLL" value="0.3" unit="rad"/>
+    <define name="DEFAULT_PITCH" value="0.5" unit="rad"/>
+    <define name="HOME_RADIUS" value="70" unit="m"/>
+  </section>
+
+  <section name="SIMU">
+    <define name="JSBSIM_MODEL" value="&quot;Malolo1&quot;"/>
+    <define name="JSBSIM_IR_ROLL_NEUTRAL" value="0." unit="deg"/>
+    <define name="JSBSIM_IR_PITCH_NEUTRAL" value="0." unit="deg"/>
+  </section>
+
+</airframe>
diff --git a/conf/airframes/juav_configuration/jUAV/microjet.xml b/conf/airframes/juav_configuration/jUAV/microjet.xml
new file mode 100644
index 0000000..daec8bf
--- /dev/null
+++ b/conf/airframes/juav_configuration/jUAV/microjet.xml
@@ -0,0 +1,283 @@
+<!DOCTYPE airframe SYSTEM "../../airframe.dtd">
+
+<!-- Microjet Multiplex (http://www.multiplex-rc.de/)
+     Tiny 1.1 board (http://paparazzi.enac.fr/wiki/Tiny)
+     Tilted infrared sensor
+     Xbee modem in API mode
+-->
+
+<airframe name="Microjet Tiny 1.1">
+
+  <servos>
+    <servo name="MOTOR"         no="0" min="1290" neutral="1290" max="1810"/>
+    <servo name="AILEVON_LEFT"  no="1" min="2000" neutral="1510" max="1000"/>
+    <servo name="AILEVON_RIGHT" no="3" min="1000" neutral="1535" max="2000"/>
+  </servos>
+
+  <commands>
+    <axis name="THROTTLE" failsafe_value="0"/>
+    <axis name="ROLL"     failsafe_value="0"/>
+    <axis name="PITCH"    failsafe_value="0"/>
+  </commands>
+
+  <rc_commands>
+    <set command="THROTTLE" value="@THROTTLE"/>
+    <set command="ROLL"     value="@ROLL"/>
+    <set command="PITCH"    value="@PITCH"/>
+  </rc_commands>
+
+  <section name="MIXER">
+    <define name="AILEVON_AILERON_RATE" value="0.75"/>
+    <define name="AILEVON_ELEVATOR_RATE" value="0.75"/>
+  </section>
+
+   <command_laws>
+    <let var="aileron"  value="@ROLL  * AILEVON_AILERON_RATE"/>
+    <let var="elevator" value="@PITCH * AILEVON_ELEVATOR_RATE"/>
+    <set servo="MOTOR"           value="@THROTTLE"/>
+    <set servo="AILEVON_LEFT"  value="$elevator - $aileron"/>
+    <set servo="AILEVON_RIGHT" value="$elevator + $aileron"/>
+  </command_laws>
+
+  <section name="AUTO1" prefix="AUTO1_">
+    <define name="MAX_ROLL" value="0.7"/>
+    <define name="MAX_PITCH" value="0.6"/>
+  </section>
+
+  <!--section name="adc" prefix="ADC_CHANNEL_">
+    <define name="IR1" value="ADC_1"/>
+    <define name="IR2" value="ADC_2"/>
+    <define name="IR_TOP" value="ADC_0"/>
+    <define name="IR_NB_SAMPLES" value="16"/>
+  </section-->
+
+  <section name="INFRARED" prefix="IR_">
+    <define name="ADC_IR1_NEUTRAL" value="512"/>
+    <define name="ADC_IR2_NEUTRAL" value="512"/>
+    <define name="ADC_TOP_NEUTRAL" value="512"/>
+
+    <define name="LATERAL_CORRECTION" value="1."/>
+    <define name="LONGITUDINAL_CORRECTION" value="1."/>
+    <define name="VERTICAL_CORRECTION" value="1.5"/>
+
+    <define name="HORIZ_SENSOR_TILTED" value="1"/>
+    <define name="IR2_SIGN" value="-1"/>
+    <define name="TOP_SIGN" value="-1"/>
+
+    <define name="ROLL_NEUTRAL_DEFAULT" value="-3.6" unit="deg"/>
+    <define name="PITCH_NEUTRAL_DEFAULT" value="5" unit="deg"/>
+
+    <define name="CORRECTION_UP" value="1."/>
+    <define name="CORRECTION_DOWN" value="1."/>
+    <define name="CORRECTION_LEFT" value="1."/>
+    <define name="CORRECTION_RIGHT" value="1."/>
+  </section>
+
+  <section name="IMU" prefix="IMU_">
+    <define name="GYRO_P_SIGN"  value="-1."/>
+    <define name="GYRO_P_NEUTRAL" value="512"/>
+    <define name="GYRO_P_SENS" value="1." integer="16"/>
+  </section>
+
+  <section name="IMU" prefix="IMU_">
+    <define name="GYRO_P_SIGN"  value="1"/>
+    <define name="GYRO_P_NEUTRAL" value="500"/>
+    <define name="GYRO_P_SENS" value="0.137518981" integer="16"/>
+  </section>
+
+  <section name="BAT">
+    <define name="MILLIAMP_AT_FULL_THROTTLE" value="2000"/>
+
+    <define name="CATASTROPHIC_BAT_LEVEL" value="9.3" unit="V"/>
+  </section>
+
+  <section name="MISC">
+    <define name="NOMINAL_AIRSPEED" value="13." unit="m/s"/>
+    <define name="CARROT" value="5." unit="s"/>
+    <define name="KILL_MODE_DISTANCE" value="(1.5*MAX_DIST_FROM_HOME)"/>
+    <define name="CONTROL_FREQUENCY" value="60" unit="Hz"/>
+<!--    <define name="XBEE_INIT" value="\"ATPL2\rATRN1\rATTT80\r\""/> -->
+<!--    <define name="NO_XBEE_API_INIT" value="TRUE"/> -->
+    <!--define name="ALT_KALMAN_ENABLED" value="TRUE"/-->
+
+    <define name="TRIGGER_DELAY" value="1."/>
+    <define name="DEFAULT_CIRCLE_RADIUS" value="80."/>
+
+    <!--define name="GLIDE_AIRSPEED" value="10"/>
+    <define name="GLIDE_VSPEED" value="3."/>
+    <define name="GLIDE_PITCH" value="45" unit="deg"/-->
+  </section>
+
+  <section name="VERTICAL CONTROL" prefix="V_CTL_">
+
+    <define name="POWER_CTL_BAT_NOMINAL" value="11.1" unit="volt"/>
+    <!-- outer loop proportional gain -->
+    <define name="ALTITUDE_PGAIN" value="-0.03"/>
+    <!-- outer loop saturation -->
+    <define name="ALTITUDE_MAX_CLIMB" value="2."/>
+
+    <!-- auto throttle inner loop -->
+    <define name="AUTO_THROTTLE_NOMINAL_CRUISE_THROTTLE" value="0.32"/>
+    <define name="AUTO_THROTTLE_MIN_CRUISE_THROTTLE" value="0.25"/>
+    <define name="AUTO_THROTTLE_MAX_CRUISE_THROTTLE" value="0.65"/>
+    <define name="AUTO_THROTTLE_LOITER_TRIM" value="1500"/>
+    <define name="AUTO_THROTTLE_DASH_TRIM" value="-4000"/>
+    <define name="AUTO_THROTTLE_CLIMB_THROTTLE_INCREMENT" value="0.15" unit="%/(m/s)"/>
+    <define name="AUTO_THROTTLE_PGAIN" value="-0.01"/>
+    <define name="AUTO_THROTTLE_IGAIN" value="0.1"/>
+    <define name="AUTO_THROTTLE_PITCH_OF_VZ_PGAIN" value="0.05"/>
+
+    <!-- auto pitch inner loop -->
+    <!--define name="AUTO_PITCH_PGAIN" value="0.05"/>
+    <define name="AUTO_PITCH_IGAIN" value="0.075"/>
+    <define name="AUTO_PITCH_MAX_PITCH" value="0.35"/>
+    <define name="AUTO_PITCH_MIN_PITCH" value="-0.35"/-->
+
+   <define name="THROTTLE_SLEW" value="0.5"/>
+   <define name="THROTTLE_SLEW_LIMITER" value="2" unit="s"/>
+
+  </section>
+
+  <section name="HORIZONTAL CONTROL" prefix="H_CTL_">
+    <define name="COURSE_PGAIN" value="-1.4"/>
+    <define name="ROLL_MAX_SETPOINT" value="0.6" unit="radians"/>
+    <define name="PITCH_MAX_SETPOINT" value="0.5" unit="radians"/>
+    <define name="PITCH_MIN_SETPOINT" value="-0.5" unit="radians"/>
+    <define name="PITCH_PGAIN" value="-12000."/>
+    <define name="PITCH_DGAIN" value="1.5"/>
+    <define name="ELEVATOR_OF_ROLL" value="1250"/>
+    <define name="ROLL_SLEW" value="0.1"/>
+    <define name="ROLL_ATTITUDE_GAIN" value="-7500"/>
+    <define name="ROLL_RATE_GAIN" value="-1500"/>
+  </section>
+
+  <section name="NAV">
+    <define name="NAV_GLIDE_PITCH_TRIM" value="0"/>
+    <define name="NAV_CROSS_TRACK_ERROR_IGAIN" value="0.05"/>
+    <define name="NAV_CROSS_TRACK_ERROR_MAX" value="10." unit="deg"/>
+  </section>
+
+  <section name="AGGRESSIVE" prefix="AGR_">
+    <define name="BLEND_START" value="20"/><!-- Altitude Error to Initiate Aggressive Climb CANNOT BE ZERO!!-->
+    <define name="BLEND_END" value="10"/><!-- Altitude Error to Blend Aggressive to Regular Climb Modes  CANNOT BE ZERO!!-->
+    <define name="CLIMB_THROTTLE" value="1.00"/><!-- Gaz for Aggressive Climb -->
+    <define name="CLIMB_PITCH" value="0.3"/><!-- Pitch for Aggressive Climb -->
+    <define name="DESCENT_THROTTLE" value="0.1"/><!-- Gaz for Aggressive Decent -->
+    <define name="DESCENT_PITCH" value="-0.25"/><!-- Pitch for Aggressive Decent -->
+    <define name="CLIMB_NAV_RATIO" value="0.8"/><!-- Percent Navigation for Altitude Error Equal to Start Altitude -->
+    <define name="DESCENT_NAV_RATIO" value="1.0"/>
+    </section>
+
+  <!--section name="GYRO_GAINS">
+    <define name="GYRO_MAX_RATE" value="200."/>
+    <define name="ROLLRATESUM_NB_SAMPLES" value="64"/>
+    <define name="ALT_ROLL__PGAIN" value="1.0"/>
+    <define name="ROLL_RATE_PGAIN" value="1000.0"/>
+    <define name="ROLL_RATE_IGAIN" value="0.0"/>
+    <define name="ROLL_RATE_DGAIN" value="0.0"/>
+  </section-->
+
+  <section name="FAILSAFE" prefix="FAILSAFE_">
+    <define name="DELAY_WITHOUT_GPS" value="0.5" unit="s"/>
+    <define name="DEFAULT_THROTTLE" value="0.3" unit="%"/>
+    <define name="DEFAULT_ROLL" value="0.3" unit="rad"/>
+    <define name="DEFAULT_PITCH" value="0.5" unit="rad"/>
+    <define name="HOME_RADIUS" value="100" unit="m"/>
+  </section>
+
+  <section name="SIMU">
+    <define name="JSBSIM_MODEL" value="&quot;Malolo1&quot;"/>
+    <define name="JSBSIM_INIT"	value="&quot;Malolo1-IC&quot;"/>
+    <define name="JSBSIM_LAUNCHSPEED"	value="60.0"/>
+    <define name="JSBSIM_IR_ROLL_NEUTRAL" value="0." unit="deg"/>
+    <define name="JSBSIM_IR_PITCH_NEUTRAL" value="0." unit="deg"/>
+  </section>
+
+  <!--section name="CATAPULT" prefix="NAV_CATAPULT_" >
+	<define name="MOTOR_DELAY" value="0.75" />
+	<define name="HEADING_DELAY" value="3" />
+	<define name="ACCELERATION_THRESHOLD" value="1.75" />
+ 	<define name="INITIAL_PITCH" value="(15.0/57.0)" />
+	<define name="INITIAL_THROTTLE" value="1.0" />
+   </section-->
+
+
+
+  <firmware name="fixedwing">
+    <target name="sim" 			board="pc" />
+    <target name="jsbsim"       board="pc"/>
+    <target name="ap" 			board="tiny_1.1"/>
+
+    <define name="AGR_CLIMB" />
+    <define name="LOITER_TRIM" />
+    <define name="ALT_KALMAN" />
+
+    <subsystem name="radio_control" type="ppm"/>
+
+    <!-- Communication -->
+    <subsystem name="telemetry" 	type="xbee_api">
+      <configure name="MODEM_BAUD" 		value="B9600"/>
+    </subsystem>
+
+    <subsystem name="control"/>
+    <!-- Sensors -->
+    <subsystem name="imu"       type="analog">
+      <configure name="GYRO_P" value="ADC_3"/>
+    </subsystem>
+    <subsystem name="ahrs"      type="infrared"/>
+    <subsystem name="gps"       type="ublox_utm"/>
+    <subsystem name="navigation"/>
+    <subsystem name="ins" type="alt_float"/>
+
+	<define name="AGR_CLIMB"/>
+	<define name="LOITER_TRIM"/>
+	<define name="ALT_KALMAN"/>
+	<define name="TUNE_AGRESSIVE_CLIMB"/>
+
+  </firmware>
+
+  <!--section name="CATAPULT" prefix="NAV_CATAPULT_">
+    <define name="MOTOR_DELAY" value="0.75" unit="seconds"/>
+    <define name="HEADING_DELAY" value="1.0" unit="seconds"/>
+    <define name="ACCELERATION_THRESHOLD" value="1.75"/>
+    <define name="INITIAL_PITCH" value="15.0" unit="deg"/>
+    <define name="INITIAL_THROTTLE" value="1.0"/>
+  </section-->
+
+    <!--section name="Takeoff" prefix="Takeoff_">
+    <define name="Height" value="60" unit="m"/>
+    <define name="Speed" value="40" unit="m/s"/>
+    <define name="Distance" value="10" unit="m"/>
+    <define name="MinSpeed" value="5" unit="m/s"/>
+    </section-->
+
+<section name="GCS">
+    <define name="AC_ICON" value="flyingwing"/>
+  </section>
+
+  <modules>
+    <load name="openlog.xml"/>
+    <load name="nav_survey_polygon.xml"/>
+    <load name="nav_line_border.xml"/>
+    <load name="nav_line.xml"/>
+    <load name="nav_smooth.xml"/>
+    <load name="nav_flower.xml"/>
+    <load name="nav_line_osam.xml"/>
+    <load name="nav_survey_poly_osam.xml"/>
+    <load name="nav_vertical_raster.xml"/>
+    <!--load name="nav_catapult.xml"/-->
+    <load name="nav_bungee_takeoff.xml"/>
+    <load name="infrared_adc.xml"/>
+    <!--load name="digital_cam_servo.xml">
+      <define name="DC_SHUTTER_SERVO" value="COMMAND_SHUTTER" />
+    </load-->
+  </modules>
+
+
+  <firmware name="setup">
+    <target name="tunnel"           board="tiny_1.1" />
+    <target name="usb_tunnel_0"     board="tiny_1.1" />
+    <target name="usb_tunnel_1"     board="tiny_1.1" />
+  </firmware>
+
+</airframe>
diff --git a/conf/airframes/juav_configuration/jUAV/microjet_example.xml b/conf/airframes/juav_configuration/jUAV/microjet_example.xml
new file mode 100644
index 0000000..9cbfaee
--- /dev/null
+++ b/conf/airframes/juav_configuration/jUAV/microjet_example.xml
@@ -0,0 +1,221 @@
+<!DOCTYPE airframe SYSTEM "../../airframe.dtd">
+
+<!-- Microjet Multiplex (http://www.multiplex-rc.de/)
+     Tiny 1.1 board (http://paparazzi.enac.fr/wiki/Tiny)
+     Tilted infrared sensor
+     Xbee modem in API mode
+-->
+
+<airframe name="Microjet Tiny 1.1">
+
+	
+	<modules>
+		<load name="AOA_adc.xml">  
+			<configure name="ADC_AOA" value="ADC_6"/>
+			<define name="AOA_OFFSET" value="-0.135000005364"/>   
+			<define name="AOA_FILTER" value="0.875999987125"/>   
+			<define name="USE_AOA"/>  
+		</load> 
+
+    <load name="infrared_adc.xml"/>
+
+	</modules>
+
+  <servos>
+    <servo name="MOTOR"         no="0" min="1290" neutral="1290" max="1810"/>
+    <servo name="AILEVON_LEFT"  no="1" min="2000" neutral="1510" max="1000"/>
+    <servo name="AILEVON_RIGHT" no="3" min="1000" neutral="1535" max="2000"/>
+  </servos>
+
+  <commands>
+    <axis name="THROTTLE" failsafe_value="0"/>
+    <axis name="ROLL"     failsafe_value="0"/>
+    <axis name="PITCH"    failsafe_value="0"/>
+  </commands>
+
+  <rc_commands>
+    <set command="THROTTLE" value="@THROTTLE"/>
+    <set command="ROLL"     value="@ROLL"/>
+    <set command="PITCH"    value="@PITCH"/>
+  </rc_commands>
+
+  <section name="MIXER">
+    <define name="AILEVON_AILERON_RATE" value="0.75"/>
+    <define name="AILEVON_ELEVATOR_RATE" value="0.75"/>
+  </section>
+
+  <command_laws>
+    <let var="aileron"  value="@ROLL  * AILEVON_AILERON_RATE"/>
+    <let var="elevator" value="@PITCH * AILEVON_ELEVATOR_RATE"/>
+    <set servo="MOTOR"         value="@THROTTLE"/>
+    <set servo="AILEVON_LEFT"  value="$elevator + $aileron"/>
+    <set servo="AILEVON_RIGHT" value="$elevator - $aileron"/>
+  </command_laws>
+
+  <section name="AUTO1" prefix="AUTO1_">
+    <define name="MAX_ROLL" value="0.7"/>
+    <define name="MAX_PITCH" value="0.6"/>
+  </section>
+
+  <section name="INFRARED" prefix="IR_">
+    <define name="ADC_IR1_NEUTRAL" value="512"/>
+    <define name="ADC_IR2_NEUTRAL" value="512"/>
+    <define name="ADC_TOP_NEUTRAL" value="512"/>
+
+    <define name="LATERAL_CORRECTION" value="1."/>
+    <define name="LONGITUDINAL_CORRECTION" value="1."/>
+    <define name="VERTICAL_CORRECTION" value="1.5"/>
+
+    <define name="HORIZ_SENSOR_TILTED" value="1"/>
+    <define name="IR2_SIGN" value="-1"/>
+    <define name="TOP_SIGN" value="-1"/>
+
+    <define name="ROLL_NEUTRAL_DEFAULT" value="-3.6" unit="deg"/>
+    <define name="PITCH_NEUTRAL_DEFAULT" value="5" unit="deg"/>
+
+    <define name="CORRECTION_UP" value="1."/>
+    <define name="CORRECTION_DOWN" value="1."/>
+    <define name="CORRECTION_LEFT" value="1."/>
+    <define name="CORRECTION_RIGHT" value="1."/>
+  </section>
+
+  <section name="GYRO" prefix="GYRO_">
+    <define name="ADC_ROLL_NEUTRAL" value="500"/>
+    <define name="DYNAMIC_RANGE" value="300" unit="deg/s"/>
+    <define name="ADXRS300_RESISTOR_BRIDGE" value="(3.3/(3.3+1.8))"/>
+    <define name="ADXRS300_SENSITIVITY" value="5" unit="mV/(deg/s)"/>
+    <define name="ROLL_SCALE" value="3.3*1000./1024./(GYRO_ADXRS300_SENSITIVITY*GYRO_ADXRS300_RESISTOR_BRIDGE)" unit="deg/s/adc_unit"/>
+    <define name="ROLL_DIRECTION" value="1."/>
+  </section>
+
+  <section name="BAT">
+    <define name="MILLIAMP_AT_FULL_THROTTLE" value="2000"/>
+
+    <define name="CATASTROPHIC_BAT_LEVEL" value="9.3" unit="V"/>
+  </section>
+
+  <section name="MISC">
+    <define name="NOMINAL_AIRSPEED" value="13." unit="m/s"/>
+    <define name="CARROT" value="5." unit="s"/>
+    <define name="KILL_MODE_DISTANCE" value="(1.5*MAX_DIST_FROM_HOME)"/>
+    <define name="CONTROL_FREQUENCY" value="60" unit="Hz"/>
+    <define name="XBEE_INIT" value="&quot;ATPL2\rATRN5\rATTT80\r&quot;"/>
+<!--    <define name="NO_XBEE_API_INIT" value="TRUE"/> -->
+    <define name="ALT_KALMAN_ENABLED" value="TRUE"/>
+
+    <define name="DEFAULT_CIRCLE_RADIUS" value="80."/>
+
+    <define name="GLIDE_AIRSPEED" value="10"/>
+    <define name="GLIDE_VSPEED" value="3."/>
+    <define name="GLIDE_PITCH" value="45" unit="deg"/>
+  </section>
+
+  <section name="VERTICAL CONTROL" prefix="V_CTL_">
+    <define name="POWER_CTL_BAT_NOMINAL" value="11.1" unit="volt"/>
+    <!-- outer loop proportional gain -->
+    <define name="ALTITUDE_PGAIN" value="-0.03"/>
+    <!-- outer loop saturation -->
+    <define name="ALTITUDE_MAX_CLIMB" value="2."/>
+
+    <!-- auto throttle inner loop -->
+    <define name="AUTO_THROTTLE_NOMINAL_CRUISE_THROTTLE" value="0.32"/>
+    <define name="AUTO_THROTTLE_MIN_CRUISE_THROTTLE" value="0.25"/>
+    <define name="AUTO_THROTTLE_MAX_CRUISE_THROTTLE" value="0.65"/>
+    <define name="AUTO_THROTTLE_LOITER_TRIM" value="1500"/>
+    <define name="AUTO_THROTTLE_DASH_TRIM" value="-4000"/>
+    <define name="AUTO_THROTTLE_CLIMB_THROTTLE_INCREMENT" value="0.15" unit="%/(m/s)"/>
+    <define name="AUTO_THROTTLE_PGAIN" value="-0.01"/>
+    <define name="AUTO_THROTTLE_IGAIN" value="0.1"/>
+    <define name="AUTO_THROTTLE_PITCH_OF_VZ_PGAIN" value="0.05"/>
+
+    <define name="THROTTLE_SLEW_LIMITER" value="2" unit="s"/>
+  </section>
+
+  <section name="HORIZONTAL CONTROL" prefix="H_CTL_">
+    <define name="COURSE_PGAIN" value="-1.4"/>
+
+    <define name="ROLL_MAX_SETPOINT" value="0.6" unit="radians"/>
+    <define name="PITCH_MAX_SETPOINT" value="0.5" unit="radians"/>
+    <define name="PITCH_MIN_SETPOINT" value="-0.5" unit="radians"/>
+
+    <define name="PITCH_PGAIN" value="-12000."/>
+    <define name="PITCH_DGAIN" value="1.5"/>
+
+    <define name="ELEVATOR_OF_ROLL" value="1250"/>
+
+    <define name="ROLL_SLEW" value="0.1"/>
+
+    <define name="ROLL_ATTITUDE_GAIN" value="-7500"/>
+    <define name="ROLL_RATE_GAIN" value="-1500"/>
+  </section>
+
+  <section name="AGGRESSIVE" prefix="AGR_">
+    <define name="BLEND_START" value="20"/><!-- Altitude Error to Initiate Aggressive Climb CANNOT BE ZERO!!-->
+    <define name="BLEND_END" value="10"/><!-- Altitude Error to Blend Aggressive to Regular Climb Modes  CANNOT BE ZERO!!-->
+    <define name="CLIMB_THROTTLE" value="1.00"/><!-- Gaz for Aggressive Climb -->
+    <define name="CLIMB_PITCH" value="0.3"/><!-- Pitch for Aggressive Climb -->
+    <define name="DESCENT_THROTTLE" value="0.1"/><!-- Gaz for Aggressive Decent -->
+    <define name="DESCENT_PITCH" value="-0.25"/><!-- Pitch for Aggressive Decent -->
+    <define name="CLIMB_NAV_RATIO" value="0.8"/><!-- Percent Navigation for Altitude Error Equal to Start Altitude -->
+    <define name="DESCENT_NAV_RATIO" value="1.0"/>
+    </section>
+
+  <section name="FAILSAFE" prefix="FAILSAFE_">
+    <define name="DELAY_WITHOUT_GPS" value="2" unit="s"/>
+    <define name="DEFAULT_THROTTLE" value="0.3" unit="%"/>
+    <define name="DEFAULT_ROLL" value="0.3" unit="rad"/>
+    <define name="DEFAULT_PITCH" value="0.5" unit="rad"/>
+  </section>
+
+  <section name="DATALINK" prefix="DATALINK_">
+    <define name="DEVICE_TYPE" value="XBEE"/>
+    <define name="DEVICE_ADDRESS" value="...."/>
+  </section>
+  
+  
+  <section name="SIMU">
+    <define name="JSBSIM_MODEL" value="&quot;Malolo1&quot;"/>
+    <define name="JSBSIM_IR_ROLL_NEUTRAL" value="RadOfDeg(0.)"/>
+    <define name="JSBSIM_IR_PITCH_NEUTRAL" value="RadOfDeg(0.)"/>
+  </section>
+
+
+  <firmware name="fixedwing">
+    <target name="sim" 			board="pc" />
+    <target name="jsbsim"       board="pc"/>
+    <target name="ap" 			board="tiny_1.1"/>
+
+    <define name="AGR_CLIMB" />
+    <define name="LOITER_TRIM" />
+    <define name="ALT_KALMAN" />
+
+    <subsystem name="radio_control" type="ppm"/>
+
+    <!-- Communication -->
+    <subsystem name="telemetry" 	type="xbee_api">
+      <configure name="MODEM_BAUD" 		value="B9600"/>
+    </subsystem>
+    <!-- Communication -->
+    <!--subsystem name="telemetry" 	type="transparent">
+      <configure name="MODEM_BAUD" 		value="B9600"/>
+    </subsystem-->
+
+    <subsystem name="control"/>
+    <!-- Sensors -->
+    <!--subsystem name="gyro"          type="roll"/-->
+    <subsystem name="imu"          type="analog"/>
+    <subsystem name="ahrs" 		type="infrared"/>
+    <subsystem name="gps" 		    type="ublox_utm"/>
+    <subsystem name="navigation"/>
+    <subsystem name="ins" type="alt_float"/>
+
+  </firmware>
+
+  <firmware name="setup">
+    <target name="tunnel"           board="tiny_1.1" />
+    <target name="usb_tunnel_0"     board="tiny_1.1" />
+    <target name="usb_tunnel_1"     board="tiny_1.1" />
+    <target name="setup_actuators"  board="tiny_1.1" />
+  </firmware>
+
+</airframe>
diff --git a/conf/airframes/juav_configuration/jUAV/microjet_lisa_m.xml b/conf/airframes/juav_configuration/jUAV/microjet_lisa_m.xml
new file mode 100644
index 0000000..e7cbd85
--- /dev/null
+++ b/conf/airframes/juav_configuration/jUAV/microjet_lisa_m.xml
@@ -0,0 +1,212 @@
+<!DOCTYPE airframe SYSTEM "../../airframe.dtd">
+
+<!-- Microjet Multiplex (http://www.multiplex-rc.de/)
+     Lisa/M v2.0 board (http://paparazzi.enac.fr/wiki/Lisa/M_v20)
+     Aspirin IMU v2.1
+     Xbee modem in transparent mode
+-->
+
+<airframe name="Microjet Tiny 1.1">
+
+  <firmware name="fixedwing">
+    <target name="sim" 	board="pc"/>
+    <target name="nps"   board="pc">
+      <subsystem name="fdm" type="jsbsim"/>
+    </target>
+    <target name="ap"   board="tiny_1.1">
+      <configure name="PERIODIC_FREQUENCY" value="120"/>
+      <configure name="AHRS_PROPAGATE_FREQUENCY" value="100"/>
+      <configure name="AHRS_CORRECT_FREQUENCY" value="100"/>
+    </target>
+
+    <define name="AGR_CLIMB"/>
+    <define name="LOITER_TRIM"/>
+    <define name="STRONG_WIND"/>
+
+    <define name="USE_BAROMETER" value="TRUE"/>
+    <subsystem name="radio_control" type="ppm"/>
+
+    <!-- Communication -->
+    <subsystem name="telemetry" 	type="transparent"/>
+
+    <!-- Sensors -->
+    <subsystem name="imu"           type="aspirin_v2.1"/>
+    <subsystem name="gps"           type="ublox"/>
+
+    <subsystem name="ahrs"          type="int_cmpl_quat"/>
+    <subsystem name="control"/>
+    <subsystem name="navigation"/>
+    <subsystem name="ins" type="alt_float"/>
+  </firmware>
+
+  <modules>
+    <load name="sys_mon.xml"/>
+    <load name="baro_sim.xml"/>
+
+    <!-- extra navigation routines -->
+    <load name="nav_bungee_takeoff.xml"/>
+    <load name="nav_line.xml"/>
+    <load name="nav_line_border.xml"/>
+    <load name="nav_line_osam.xml"/>
+    <load name="nav_flower.xml"/>
+    <load name="nav_smooth.xml"/>
+    <load name="nav_survey_polygon.xml"/>
+    <load name="nav_survey_poly_osam.xml"/>
+    <load name="nav_vertical_raster.xml"/>
+
+    <load name="digital_cam_servo.xml">
+      <define name="DC_SHUTTER_SERVO" value="COMMAND_SHUTTER" />
+    </load>
+  </modules>
+
+  <servos>
+    <servo name="MOTOR"         no="0" min="1290" neutral="1290" max="1810"/>
+    <servo name="AILEVON_LEFT"  no="1" min="2000" neutral="1510" max="1000"/>
+    <servo name="AILEVON_RIGHT" no="3" min="1000" neutral="1535" max="2000"/>
+  </servos>
+
+  <commands>
+    <axis name="THROTTLE" failsafe_value="0"/>
+    <axis name="ROLL"     failsafe_value="0"/>
+    <axis name="PITCH"    failsafe_value="0"/>
+    <axis name="SHUTTER"  failsafe_value="0"/>
+  </commands>
+
+  <rc_commands>
+    <set command="THROTTLE" value="@THROTTLE"/>
+    <set command="ROLL"     value="@ROLL"/>
+    <set command="PITCH"    value="@PITCH"/>
+  </rc_commands>
+
+  <section name="MIXER">
+    <define name="AILEVON_AILERON_RATE" value="0.75"/>
+    <define name="AILEVON_ELEVATOR_RATE" value="0.75"/>
+  </section>
+
+  <command_laws>
+    <let var="aileron"  value="@ROLL  * AILEVON_AILERON_RATE"/>
+    <let var="elevator" value="@PITCH * AILEVON_ELEVATOR_RATE"/>
+    <set servo="MOTOR"         value="@THROTTLE"/>
+    <set servo="AILEVON_LEFT"  value="$elevator - $aileron"/>
+    <set servo="AILEVON_RIGHT" value="$elevator + $aileron"/>
+  </command_laws>
+
+  <section name="IMU" prefix="IMU_">
+    <!-- ACCEL and GYRO calibration left out to take default datasheet values -->
+
+    <!-- replace this with your own mag calibration -->
+    <define name="MAG_X_NEUTRAL" value="-45"/>
+    <define name="MAG_Y_NEUTRAL" value="334"/>
+    <define name="MAG_Z_NEUTRAL" value="7"/>
+    <define name="MAG_X_SENS" value="4.47647816128" integer="16"/>
+    <define name="MAG_Y_SENS" value="4.71085671542" integer="16"/>
+    <define name="MAG_Z_SENS" value="4.41585354498" integer="16"/>
+
+    <define name="BODY_TO_IMU_PHI"   value="0." unit="deg"/>
+    <define name="BODY_TO_IMU_THETA" value="0." unit="deg"/>
+    <define name="BODY_TO_IMU_PSI"   value="0." unit="deg"/>
+  </section>
+
+  <section name="AHRS" prefix="AHRS_">
+    <!-- replace this with your local magnetic field -->
+    <define name="H_X" value="0.3770441"/>
+    <define name="H_Y" value="0.0193986"/>
+    <define name="H_Z" value="0.9259921"/>
+  </section>
+
+  <section name="INS" prefix="INS_">
+    <define name="ROLL_NEUTRAL_DEFAULT" value="0" unit="deg"/>
+    <define name="PITCH_NEUTRAL_DEFAULT" value="0" unit="deg"/>
+  </section>
+
+  <section name="VERTICAL CONTROL" prefix="V_CTL_">
+    <define name="POWER_CTL_BAT_NOMINAL" value="11.1" unit="volt"/>
+    <!-- outer loop proportional gain -->
+    <define name="ALTITUDE_PGAIN" value="0.03"/>
+    <!-- outer loop saturation -->
+    <define name="ALTITUDE_MAX_CLIMB" value="2."/>
+
+    <!-- auto throttle inner loop -->
+    <define name="AUTO_THROTTLE_NOMINAL_CRUISE_THROTTLE" value="0.32"/>
+    <define name="AUTO_THROTTLE_MIN_CRUISE_THROTTLE" value="0.25"/>
+    <define name="AUTO_THROTTLE_MAX_CRUISE_THROTTLE" value="0.65"/>
+    <define name="AUTO_THROTTLE_LOITER_TRIM" value="1500"/>
+    <define name="AUTO_THROTTLE_DASH_TRIM" value="-4000"/>
+    <define name="AUTO_THROTTLE_CLIMB_THROTTLE_INCREMENT" value="0.15" unit="%/(m/s)"/>
+    <define name="AUTO_THROTTLE_PGAIN" value="0.01"/>
+    <define name="AUTO_THROTTLE_IGAIN" value="0.1"/>
+    <define name="AUTO_THROTTLE_PITCH_OF_VZ_PGAIN" value="0.05"/>
+
+    <define name="THROTTLE_SLEW_LIMITER" value="2" unit="s"/>
+  </section>
+
+  <section name="HORIZONTAL CONTROL" prefix="H_CTL_">
+    <define name="COURSE_PGAIN" value="1.0"/>
+    <define name="COURSE_DGAIN" value="0.3"/>
+
+    <define name="ROLL_MAX_SETPOINT"  value="35"  unit="deg"/>
+    <define name="PITCH_MAX_SETPOINT" value="30"  unit="deg"/>
+    <define name="PITCH_MIN_SETPOINT" value="-30" unit="deg"/>
+
+    <define name="PITCH_PGAIN" value="12000."/>
+    <define name="PITCH_DGAIN" value="1.5"/>
+
+    <define name="ELEVATOR_OF_ROLL" value="1250"/>
+
+    <define name="ROLL_SLEW" value="0.1"/>
+
+    <define name="ROLL_ATTITUDE_GAIN" value="7500"/>
+    <define name="ROLL_RATE_GAIN" value="1500"/>
+  </section>
+
+  <section name="AGGRESSIVE" prefix="AGR_">
+    <define name="BLEND_START" value="20"/><!-- Altitude Error to Initiate Aggressive Climb CANNOT BE ZERO!!-->
+    <define name="BLEND_END" value="10"/><!-- Altitude Error to Blend Aggressive to Regular Climb Modes  CANNOT BE ZERO!!-->
+    <define name="CLIMB_THROTTLE" value="1.00"/><!-- Gaz for Aggressive Climb -->
+    <define name="CLIMB_PITCH" value="0.3"/><!-- Pitch for Aggressive Climb -->
+    <define name="DESCENT_THROTTLE" value="0.1"/><!-- Gaz for Aggressive Decent -->
+    <define name="DESCENT_PITCH" value="-0.25"/><!-- Pitch for Aggressive Decent -->
+    <define name="CLIMB_NAV_RATIO" value="0.8"/><!-- Percent Navigation for Altitude Error Equal to Start Altitude -->
+    <define name="DESCENT_NAV_RATIO" value="1.0"/>
+    </section>
+
+  <section name="FAILSAFE" prefix="FAILSAFE_">
+    <define name="DELAY_WITHOUT_GPS" value="2" unit="s"/>
+    <define name="DEFAULT_THROTTLE" value="0.3" unit="%"/>
+    <define name="DEFAULT_ROLL" value="0.3" unit="rad"/>
+    <define name="DEFAULT_PITCH" value="0.5" unit="rad"/>
+  </section>
+
+  <section name="AUTO1" prefix="AUTO1_">
+    <define name="MAX_ROLL" value="40." unit="deg"/>
+    <define name="MAX_PITCH" value="35." unit="deg"/>
+  </section>
+
+  <section name="BAT">
+    <define name="MILLIAMP_AT_FULL_THROTTLE" value="2000"/>
+    <define name="CATASTROPHIC_BAT_LEVEL" value="9.3" unit="V"/>
+    <define name="CRITIC_BAT_LEVEL" value="9.6" unit="V"/>
+    <define name="LOW_BAT_LEVEL" value="9.7" unit="V"/>
+    <define name="MAX_BAT_LEVEL" value="12.4" unit="V"/>
+  </section>
+
+  <section name="MISC">
+    <define name="NOMINAL_AIRSPEED" value="13." unit="m/s"/>
+    <define name="CARROT" value="5." unit="s"/>
+    <define name="KILL_MODE_DISTANCE" value="(1.5*MAX_DIST_FROM_HOME)"/>
+    <define name="CONTROL_FREQUENCY" value="60" unit="Hz"/>
+    <define name="DEFAULT_CIRCLE_RADIUS" value="80."/>
+  </section>
+
+  <section name="SIMULATOR" prefix="NPS_">
+    <define name="JSBSIM_MODEL" value="&quot;Malolo1&quot;"/>
+    <define name="JSBSIM_LAUNCHSPEED" value="20"/>
+    <define name="COMMANDS_NB" value="3"/>
+    <define name="ACTUATOR_NAMES" value="{&quot;throttle-cmd-norm&quot;, &quot;aileron-cmd-norm&quot;, &quot;elevator-cmd-norm&quot;}"/>
+    <define name="SENSORS_PARAMS" value="&quot;nps_sensors_params_default.h&quot;"/>
+    <define name="JS_AXIS_MODE" value="4"/>
+    <define name="BYPASS_AHRS" value="TRUE"/>
+    <define name="BYPASS_INS" value="TRUE"/>
+  </section>
+
+</airframe>
diff --git a/conf/airframes/juav_configuration/jUAV/microjet_rev_a.xml b/conf/airframes/juav_configuration/jUAV/microjet_rev_a.xml
new file mode 100644
index 0000000..15dea87
--- /dev/null
+++ b/conf/airframes/juav_configuration/jUAV/microjet_rev_a.xml
@@ -0,0 +1,260 @@
+<!DOCTYPE airframe SYSTEM "../../airframe.dtd">
+
+<!-- Microjet Multiplex (http://www.multiplex-rc.de/)
+     Tiny 1.1 board (http://paparazzi.enac.fr/wiki/Tiny)
+     Tilted infrared sensor
+     Xbee modem in API mode
+-->
+
+<airframe name="Microjet Tiny 1.1">
+
+  <servos>
+    <servo name="MOTOR"         no="0" min="1290" neutral="1290" max="1810"/>
+    <servo name="AILEVON_LEFT"  no="1" min="2000" neutral="1510" max="1000"/>
+    <servo name="AILEVON_RIGHT" no="3" min="1000" neutral="1535" max="2000"/>
+  </servos>
+
+  <commands>
+    <axis name="THROTTLE" failsafe_value="0"/>
+    <axis name="ROLL"     failsafe_value="0"/>
+    <axis name="PITCH"    failsafe_value="0"/>
+  </commands>
+
+  <rc_commands>
+    <set command="THROTTLE" value="@THROTTLE"/>
+    <set command="ROLL"     value="@ROLL"/>
+    <set command="PITCH"    value="@PITCH"/>
+  </rc_commands>
+
+  <section name="MIXER">
+    <define name="AILEVON_AILERON_RATE" value="0.75"/>
+    <define name="AILEVON_ELEVATOR_RATE" value="0.75"/>
+  </section>
+
+   <command_laws>
+    <let var="aileron"  value="@ROLL  * AILEVON_AILERON_RATE"/>
+    <let var="elevator" value="@PITCH * AILEVON_ELEVATOR_RATE"/>
+    <set servo="MOTOR"           value="@THROTTLE"/>
+    <set servo="AILEVON_LEFT"  value="$elevator - $aileron"/>
+    <set servo="AILEVON_RIGHT" value="$elevator + $aileron"/>
+  </command_laws>
+
+  <section name="AUTO1" prefix="AUTO1_">
+    <define name="MAX_ROLL" value="0.7"/>
+    <define name="MAX_PITCH" value="0.6"/>
+  </section>
+
+  <!--section name="adc" prefix="ADC_CHANNEL_">
+    <define name="IR1" value="ADC_1"/>
+    <define name="IR2" value="ADC_2"/>
+    <define name="IR_TOP" value="ADC_0"/>
+    <define name="IR_NB_SAMPLES" value="16"/>
+  </section-->
+
+  <section name="INFRARED" prefix="IR_">
+    <define name="ADC_IR1_NEUTRAL" value="512"/>
+    <define name="ADC_IR2_NEUTRAL" value="512"/>
+    <define name="ADC_TOP_NEUTRAL" value="512"/>
+
+    <define name="LATERAL_CORRECTION" value="1."/>
+    <define name="LONGITUDINAL_CORRECTION" value="1."/>
+    <define name="VERTICAL_CORRECTION" value="1.5"/>
+
+    <define name="HORIZ_SENSOR_TILTED" value="1"/>
+    <define name="IR2_SIGN" value="-1"/>
+    <define name="TOP_SIGN" value="-1"/>
+
+    <define name="ROLL_NEUTRAL_DEFAULT" value="-3.6" unit="deg"/>
+    <define name="PITCH_NEUTRAL_DEFAULT" value="5" unit="deg"/>
+
+    <define name="CORRECTION_UP" value="1."/>
+    <define name="CORRECTION_DOWN" value="1."/>
+    <define name="CORRECTION_LEFT" value="1."/>
+    <define name="CORRECTION_RIGHT" value="1."/>
+  </section>
+
+  <section name="IMU" prefix="IMU_">
+    <define name="GYRO_P_SIGN"  value="-1."/>
+    <define name="GYRO_P_NEUTRAL" value="512"/>
+    <define name="GYRO_P_SENS" value="1." integer="16"/>
+  </section>
+
+  <section name="IMU" prefix="IMU_">
+    <define name="GYRO_P_SIGN"  value="1"/>
+    <define name="GYRO_P_NEUTRAL" value="500"/>
+    <define name="GYRO_P_SENS" value="0.137518981" integer="16"/>
+  </section>
+
+  <section name="BAT">
+    <define name="MILLIAMP_AT_FULL_THROTTLE" value="2000"/>
+    <define name="CATASTROPHIC_BAT_LEVEL" value="9.3" unit="V"/>
+  </section>
+
+  <section name="MISC">
+    <define name="NOMINAL_AIRSPEED" value="13." unit="m/s"/>
+    <define name="CARROT" value="5." unit="s"/>
+    <define name="KILL_MODE_DISTANCE" value="(1.5*MAX_DIST_FROM_HOME)"/>
+    <define name="CONTROL_FREQUENCY" value="60" unit="Hz"/>
+    <define name="TRIGGER_DELAY" value="1."/>
+    <define name="DEFAULT_CIRCLE_RADIUS" value="80."/>
+    <!--define name="GLIDE_AIRSPEED" value="10"/>
+    <define name="GLIDE_VSPEED" value="3."/>
+    <define name="GLIDE_PITCH" value="45" unit="deg"/-->
+  </section>
+
+  <section name="VERTICAL CONTROL" prefix="V_CTL_">
+
+    <define name="POWER_CTL_BAT_NOMINAL" value="11.1" unit="volt"/>
+    <!-- outer loop proportional gain -->
+    <define name="ALTITUDE_PGAIN" value="-0.03"/>
+    <!-- outer loop saturation -->
+    <define name="ALTITUDE_MAX_CLIMB" value="2."/>
+
+    <!-- auto throttle inner loop -->
+    <define name="AUTO_THROTTLE_NOMINAL_CRUISE_THROTTLE" value="0.32"/>
+    <define name="AUTO_THROTTLE_MIN_CRUISE_THROTTLE" value="0.25"/>
+    <define name="AUTO_THROTTLE_MAX_CRUISE_THROTTLE" value="0.65"/>
+    <define name="AUTO_THROTTLE_LOITER_TRIM" value="1500"/>
+    <define name="AUTO_THROTTLE_DASH_TRIM" value="-4000"/>
+    <define name="AUTO_THROTTLE_CLIMB_THROTTLE_INCREMENT" value="0.15" unit="%/(m/s)"/>
+    <define name="AUTO_THROTTLE_PGAIN" value="-0.01"/>
+    <define name="AUTO_THROTTLE_IGAIN" value="0.1"/>
+    <define name="AUTO_THROTTLE_PITCH_OF_VZ_PGAIN" value="0.05"/>
+
+    <!-- auto pitch inner loop -->
+    <!--define name="AUTO_PITCH_PGAIN" value="0.05"/>
+    <define name="AUTO_PITCH_IGAIN" value="0.075"/>
+    <define name="AUTO_PITCH_MAX_PITCH" value="0.35"/>
+    <define name="AUTO_PITCH_MIN_PITCH" value="-0.35"/-->
+
+   <define name="THROTTLE_SLEW" value="0.5"/>
+   <define name="THROTTLE_SLEW_LIMITER" value="2" unit="s"/>
+
+  </section>
+
+  <section name="HORIZONTAL CONTROL" prefix="H_CTL_">
+    <define name="COURSE_PGAIN" value="-1.4"/>
+    <define name="ROLL_MAX_SETPOINT" value="0.6" unit="radians"/>
+    <define name="PITCH_MAX_SETPOINT" value="0.5" unit="radians"/>
+    <define name="PITCH_MIN_SETPOINT" value="-0.5" unit="radians"/>
+    <define name="PITCH_PGAIN" value="-12000."/>
+    <define name="PITCH_DGAIN" value="1.5"/>
+    <define name="ELEVATOR_OF_ROLL" value="1250"/>
+    <define name="ROLL_SLEW" value="0.1"/>
+    <define name="ROLL_ATTITUDE_GAIN" value="-7500"/>
+    <define name="ROLL_RATE_GAIN" value="-1500"/>
+  </section>
+
+  <section name="NAV">
+    <define name="NAV_GLIDE_PITCH_TRIM" value="0"/>
+    <define name="NAV_CROSS_TRACK_ERROR_IGAIN" value="0.05"/>
+    <define name="NAV_CROSS_TRACK_ERROR_MAX" value="10." unit="deg"/>
+  </section>
+
+  <section name="AGGRESSIVE" prefix="AGR_">
+    <define name="BLEND_START" value="20"/><!-- Altitude Error to Initiate Aggressive Climb CANNOT BE ZERO!!-->
+    <define name="BLEND_END" value="10"/><!-- Altitude Error to Blend Aggressive to Regular Climb Modes  CANNOT BE ZERO!!-->
+    <define name="CLIMB_THROTTLE" value="1.00"/><!-- Gaz for Aggressive Climb -->
+    <define name="CLIMB_PITCH" value="0.25"/><!-- Pitch for Aggressive Climb -->
+    <define name="DESCENT_THROTTLE" value="0.1"/><!-- Gaz for Aggressive Decent -->
+    <define name="DESCENT_PITCH" value="-0.25"/><!-- Pitch for Aggressive Decent -->
+    <define name="CLIMB_NAV_RATIO" value="0.8"/><!-- Percent Navigation for Altitude Error Equal to Start Altitude -->
+    <define name="DESCENT_NAV_RATIO" value="1.0"/>
+    </section>
+
+  <!--section name="GYRO_GAINS">
+    <define name="GYRO_MAX_RATE" value="200."/>
+    <define name="ROLLRATESUM_NB_SAMPLES" value="64"/>
+    <define name="ALT_ROLL__PGAIN" value="1.0"/>
+    <define name="ROLL_RATE_PGAIN" value="1000.0"/>
+    <define name="ROLL_RATE_IGAIN" value="0.0"/>
+    <define name="ROLL_RATE_DGAIN" value="0.0"/>
+  </section-->
+
+  <section name="FAILSAFE" prefix="FAILSAFE_">
+    <define name="DELAY_WITHOUT_GPS" value="0.5" unit="s"/>
+    <define name="DEFAULT_THROTTLE" value="0.3" unit="%"/>
+    <define name="DEFAULT_ROLL" value="0.3" unit="rad"/>
+    <define name="DEFAULT_PITCH" value="0.5" unit="rad"/>
+    <define name="HOME_RADIUS" value="100" unit="m"/>
+  </section>
+
+  <section name="SIMU">
+    <define name="JSBSIM_MODEL" value="&quot;Malolo1&quot;"/>
+    <define name="JSBSIM_INIT"	value="&quot;Malolo1-IC&quot;"/>
+    <define name="JSBSIM_LAUNCHSPEED"	value="60.0"/>
+    <define name="JSBSIM_IR_ROLL_NEUTRAL" value="0." unit="deg"/>
+    <define name="JSBSIM_IR_PITCH_NEUTRAL" value="0." unit="deg"/>
+  </section>
+
+  <firmware name="fixedwing">
+    <target name="sim" 			board="pc" />
+    <target name="jsbsim"       board="pc"/>
+    <target name="ap" 			board="tiny_1.1"/>
+
+    <subsystem name="radio_control" type="ppm"/>
+
+    <!-- Communication -->
+    <subsystem name="telemetry" 	type="xbee_api">
+      <configure name="MODEM_BAUD" 		value="B9600"/>
+    </subsystem>
+
+    <subsystem name="control"/>
+    <!-- Sensors -->
+    <subsystem name="imu"       type="analog">
+      <configure name="GYRO_P" value="ADC_3"/>
+    </subsystem>
+    <subsystem name="ahrs"      type="infrared"/>
+    <subsystem name="gps"       type="ublox_utm"/>
+    <subsystem name="navigation"/>
+    <subsystem name="ins" type="alt_float"/>
+
+	<!--define name="AGR_CLIMB"/-->
+	<!--define name="TUNE_AGRESSIVE_CLIMB"/-->
+	<define name="LOITER_TRIM"/>
+	<define name="ALT_KALMAN"/>
+
+  </firmware>
+
+  <!--section name="CATAPULT" prefix="NAV_CATAPULT_">
+    <define name="MOTOR_DELAY" value="0.75" unit="seconds"/>
+    <define name="HEADING_DELAY" value="1.0" unit="seconds"/>
+    <define name="ACCELERATION_THRESHOLD" value="1.75"/>
+    <define name="INITIAL_PITCH" value="15.0" unit="deg"/>
+    <define name="INITIAL_THROTTLE" value="1.0"/>
+  </section-->
+
+    <!--section name="Takeoff" prefix="Takeoff_">
+    <define name="Height" value="60" unit="m"/>
+    <define name="Speed" value="40" unit="m/s"/>
+    <define name="Distance" value="10" unit="m"/>
+    <define name="MinSpeed" value="5" unit="m/s"/>
+    </section-->
+
+<section name="GCS">
+    <define name="AC_ICON" value="flyingwing"/>
+  </section>
+
+  <modules>
+    <load name="openlog.xml"/>
+    <load name="nav_survey_polygon.xml"/>
+    <load name="nav_line_border.xml"/>
+    <load name="nav_line.xml"/>
+    <load name="nav_smooth.xml"/>
+    <load name="nav_flower.xml"/>
+    <load name="nav_line_osam.xml"/>
+    <load name="nav_survey_poly_osam.xml"/>
+    <load name="nav_vertical_raster.xml"/>
+    <!--load name="nav_catapult.xml"/-->
+    <load name="nav_bungee_takeoff.xml"/>
+    <load name="infrared_adc.xml"/>
+  </modules>
+
+
+  <firmware name="setup">
+    <target name="tunnel"           board="tiny_1.1" />
+    <target name="usb_tunnel_0"     board="tiny_1.1" />
+    <target name="usb_tunnel_1"     board="tiny_1.1" />
+  </firmware>
+
+</airframe>
diff --git a/conf/airframes/juav_configuration/jUAV/microjet_rev_b.xml b/conf/airframes/juav_configuration/jUAV/microjet_rev_b.xml
new file mode 100644
index 0000000..990ed55
--- /dev/null
+++ b/conf/airframes/juav_configuration/jUAV/microjet_rev_b.xml
@@ -0,0 +1,260 @@
+<!DOCTYPE airframe SYSTEM "../../airframe.dtd">
+
+<!-- Microjet Multiplex (http://www.multiplex-rc.de/)
+     Tiny 1.1 board (http://paparazzi.enac.fr/wiki/Tiny)
+     Tilted infrared sensor
+     Xbee modem in API mode
+-->
+
+<airframe name="Microjet Tiny 1.1">
+
+  <servos>
+    <servo name="MOTOR"         no="0" min="1290" neutral="1290" max="1810"/>
+    <servo name="AILEVON_LEFT"  no="1" min="2000" neutral="1510" max="1000"/>
+    <servo name="AILEVON_RIGHT" no="3" min="1000" neutral="1535" max="2000"/>
+  </servos>
+
+  <commands>
+    <axis name="THROTTLE" failsafe_value="0"/>
+    <axis name="ROLL"     failsafe_value="0"/>
+    <axis name="PITCH"    failsafe_value="0"/>
+  </commands>
+
+  <rc_commands>
+    <set command="THROTTLE" value="@THROTTLE"/>
+    <set command="ROLL"     value="@ROLL"/>
+    <set command="PITCH"    value="@PITCH"/>
+  </rc_commands>
+
+  <section name="MIXER">
+    <define name="AILEVON_AILERON_RATE" value="0.75"/>
+    <define name="AILEVON_ELEVATOR_RATE" value="0.75"/>
+  </section>
+
+   <command_laws>
+    <let var="aileron"  value="@ROLL  * AILEVON_AILERON_RATE"/>
+    <let var="elevator" value="@PITCH * AILEVON_ELEVATOR_RATE"/>
+    <set servo="MOTOR"           value="@THROTTLE"/>
+    <set servo="AILEVON_LEFT"  value="$elevator - $aileron"/>
+    <set servo="AILEVON_RIGHT" value="$elevator + $aileron"/>
+  </command_laws>
+
+  <section name="AUTO1" prefix="AUTO1_">
+    <define name="MAX_ROLL" value="0.7"/>
+    <define name="MAX_PITCH" value="0.6"/>
+  </section>
+
+  <!--section name="adc" prefix="ADC_CHANNEL_">
+    <define name="IR1" value="ADC_1"/>
+    <define name="IR2" value="ADC_2"/>
+    <define name="IR_TOP" value="ADC_0"/>
+    <define name="IR_NB_SAMPLES" value="16"/>
+  </section-->
+
+  <section name="INFRARED" prefix="IR_">
+    <define name="ADC_IR1_NEUTRAL" value="512"/>
+    <define name="ADC_IR2_NEUTRAL" value="512"/>
+    <define name="ADC_TOP_NEUTRAL" value="512"/>
+
+    <define name="LATERAL_CORRECTION" value="1."/>
+    <define name="LONGITUDINAL_CORRECTION" value="1."/>
+    <define name="VERTICAL_CORRECTION" value="1.5"/>
+
+    <define name="HORIZ_SENSOR_TILTED" value="1"/>
+    <define name="IR2_SIGN" value="-1"/>
+    <define name="TOP_SIGN" value="-1"/>
+
+    <define name="ROLL_NEUTRAL_DEFAULT" value="-3.6" unit="deg"/>
+    <define name="PITCH_NEUTRAL_DEFAULT" value="5" unit="deg"/>
+
+    <define name="CORRECTION_UP" value="1."/>
+    <define name="CORRECTION_DOWN" value="1."/>
+    <define name="CORRECTION_LEFT" value="1."/>
+    <define name="CORRECTION_RIGHT" value="1."/>
+  </section>
+
+  <section name="IMU" prefix="IMU_">
+    <define name="GYRO_P_SIGN"  value="-1."/>
+    <define name="GYRO_P_NEUTRAL" value="512"/>
+    <define name="GYRO_P_SENS" value="1." integer="16"/>
+  </section>
+
+  <section name="IMU" prefix="IMU_">
+    <define name="GYRO_P_SIGN"  value="1"/>
+    <define name="GYRO_P_NEUTRAL" value="500"/>
+    <define name="GYRO_P_SENS" value="0.137518981" integer="16"/>
+  </section>
+
+  <section name="BAT">
+    <define name="MILLIAMP_AT_FULL_THROTTLE" value="2000"/>
+    <define name="CATASTROPHIC_BAT_LEVEL" value="9.3" unit="V"/>
+  </section>
+
+  <section name="MISC">
+    <define name="NOMINAL_AIRSPEED" value="13." unit="m/s"/>
+    <define name="CARROT" value="5." unit="s"/>
+    <define name="KILL_MODE_DISTANCE" value="(1.5*MAX_DIST_FROM_HOME)"/>
+    <define name="CONTROL_FREQUENCY" value="60" unit="Hz"/>
+    <define name="TRIGGER_DELAY" value="1."/>
+    <define name="DEFAULT_CIRCLE_RADIUS" value="80."/>
+    <!--define name="GLIDE_AIRSPEED" value="10"/>
+    <define name="GLIDE_VSPEED" value="3."/>
+    <define name="GLIDE_PITCH" value="45" unit="deg"/-->
+  </section>
+
+  <section name="VERTICAL CONTROL" prefix="V_CTL_">
+
+    <define name="POWER_CTL_BAT_NOMINAL" value="11.1" unit="volt"/>
+    <!-- outer loop proportional gain -->
+    <define name="ALTITUDE_PGAIN" value="-0.03"/>
+    <!-- outer loop saturation -->
+    <define name="ALTITUDE_MAX_CLIMB" value="2."/>
+
+    <!-- auto throttle inner loop -->
+    <define name="AUTO_THROTTLE_NOMINAL_CRUISE_THROTTLE" value="0.32"/>
+    <define name="AUTO_THROTTLE_MIN_CRUISE_THROTTLE" value="0.25"/>
+    <define name="AUTO_THROTTLE_MAX_CRUISE_THROTTLE" value="0.65"/>
+    <define name="AUTO_THROTTLE_LOITER_TRIM" value="1500"/>
+    <define name="AUTO_THROTTLE_DASH_TRIM" value="-4000"/>
+    <define name="AUTO_THROTTLE_CLIMB_THROTTLE_INCREMENT" value="0.15" unit="%/(m/s)"/>
+    <define name="AUTO_THROTTLE_PGAIN" value="-0.01"/>
+    <define name="AUTO_THROTTLE_IGAIN" value="0.1"/>
+    <define name="AUTO_THROTTLE_PITCH_OF_VZ_PGAIN" value="0.05"/>
+
+    <!-- auto pitch inner loop -->
+    <!--define name="AUTO_PITCH_PGAIN" value="0.05"/>
+    <define name="AUTO_PITCH_IGAIN" value="0.075"/>
+    <define name="AUTO_PITCH_MAX_PITCH" value="0.35"/>
+    <define name="AUTO_PITCH_MIN_PITCH" value="-0.35"/-->
+
+   <define name="THROTTLE_SLEW" value="0.5"/>
+   <define name="THROTTLE_SLEW_LIMITER" value="2" unit="s"/>
+
+  </section>
+
+  <section name="HORIZONTAL CONTROL" prefix="H_CTL_">
+    <define name="COURSE_PGAIN" value="-1.4"/>
+    <define name="ROLL_MAX_SETPOINT" value="0.6" unit="radians"/>
+    <define name="PITCH_MAX_SETPOINT" value="0.5" unit="radians"/>
+    <define name="PITCH_MIN_SETPOINT" value="-0.5" unit="radians"/>
+    <define name="PITCH_PGAIN" value="-12000."/>
+    <define name="PITCH_DGAIN" value="0.5"/>
+    <define name="ELEVATOR_OF_ROLL" value="1250"/>
+    <define name="ROLL_SLEW" value="0.1"/>
+    <define name="ROLL_ATTITUDE_GAIN" value="-7500"/>
+    <define name="ROLL_RATE_GAIN" value="-1500"/>
+  </section>
+
+  <section name="NAV">
+    <define name="NAV_GLIDE_PITCH_TRIM" value="0"/>
+    <define name="NAV_CROSS_TRACK_ERROR_IGAIN" value="0.05"/>
+    <define name="NAV_CROSS_TRACK_ERROR_MAX" value="10." unit="deg"/>
+  </section>
+
+  <section name="AGGRESSIVE" prefix="AGR_">
+    <define name="BLEND_START" value="20"/><!-- Altitude Error to Initiate Aggressive Climb CANNOT BE ZERO!!-->
+    <define name="BLEND_END" value="10"/><!-- Altitude Error to Blend Aggressive to Regular Climb Modes  CANNOT BE ZERO!!-->
+    <define name="CLIMB_THROTTLE" value="1.00"/><!-- Gaz for Aggressive Climb -->
+    <define name="CLIMB_PITCH" value="0.35"/><!-- Pitch for Aggressive Climb -->
+    <define name="DESCENT_THROTTLE" value="0.1"/><!-- Gaz for Aggressive Decent -->
+    <define name="DESCENT_PITCH" value="-0.25"/><!-- Pitch for Aggressive Decent -->
+    <define name="CLIMB_NAV_RATIO" value="0.8"/><!-- Percent Navigation for Altitude Error Equal to Start Altitude -->
+    <define name="DESCENT_NAV_RATIO" value="1.0"/>
+    </section>
+
+  <!--section name="GYRO_GAINS">
+    <define name="GYRO_MAX_RATE" value="200."/>
+    <define name="ROLLRATESUM_NB_SAMPLES" value="64"/>
+    <define name="ALT_ROLL__PGAIN" value="1.0"/>
+    <define name="ROLL_RATE_PGAIN" value="1000.0"/>
+    <define name="ROLL_RATE_IGAIN" value="0.0"/>
+    <define name="ROLL_RATE_DGAIN" value="0.0"/>
+  </section-->
+
+  <section name="FAILSAFE" prefix="FAILSAFE_">
+    <define name="DELAY_WITHOUT_GPS" value="0.5" unit="s"/>
+    <define name="DEFAULT_THROTTLE" value="0.3" unit="%"/>
+    <define name="DEFAULT_ROLL" value="0.3" unit="rad"/>
+    <define name="DEFAULT_PITCH" value="0.5" unit="rad"/>
+    <define name="HOME_RADIUS" value="100" unit="m"/>
+  </section>
+
+  <section name="SIMU">
+    <define name="JSBSIM_MODEL" value="&quot;Malolo1&quot;"/>
+    <define name="JSBSIM_INIT"	value="&quot;Malolo1-IC&quot;"/>
+    <define name="JSBSIM_LAUNCHSPEED"	value="60.0"/>
+    <define name="JSBSIM_IR_ROLL_NEUTRAL" value="0." unit="deg"/>
+    <define name="JSBSIM_IR_PITCH_NEUTRAL" value="0." unit="deg"/>
+  </section>
+
+  <firmware name="fixedwing">
+    <target name="sim" 			board="pc" />
+    <target name="jsbsim"       board="pc"/>
+    <target name="ap" 			board="tiny_1.1"/>
+
+    <subsystem name="radio_control" type="ppm"/>
+
+    <!-- Communication -->
+    <subsystem name="telemetry" 	type="xbee_api">
+      <configure name="MODEM_BAUD" 		value="B9600"/>
+    </subsystem>
+
+    <subsystem name="control"/>
+    <!-- Sensors -->
+    <subsystem name="imu"       type="analog">
+      <configure name="GYRO_P" value="ADC_3"/>
+    </subsystem>
+    <subsystem name="ahrs"      type="infrared"/>
+    <subsystem name="gps"       type="ublox_utm"/>
+    <subsystem name="navigation"/>
+    <subsystem name="ins" type="alt_float"/>
+
+	<define name="AGR_CLIMB"/>
+	<!--define name="TUNE_AGRESSIVE_CLIMB"/-->
+	<define name="LOITER_TRIM"/>
+	<define name="ALT_KALMAN"/>
+
+  </firmware>
+
+  <!--section name="CATAPULT" prefix="NAV_CATAPULT_">
+    <define name="MOTOR_DELAY" value="0.75" unit="seconds"/>
+    <define name="HEADING_DELAY" value="1.0" unit="seconds"/>
+    <define name="ACCELERATION_THRESHOLD" value="1.75"/>
+    <define name="INITIAL_PITCH" value="15.0" unit="deg"/>
+    <define name="INITIAL_THROTTLE" value="1.0"/>
+  </section-->
+
+    <!--section name="Takeoff" prefix="Takeoff_">
+    <define name="Height" value="60" unit="m"/>
+    <define name="Speed" value="40" unit="m/s"/>
+    <define name="Distance" value="10" unit="m"/>
+    <define name="MinSpeed" value="5" unit="m/s"/>
+    </section-->
+
+<section name="GCS">
+    <define name="AC_ICON" value="flyingwing"/>
+  </section>
+
+  <modules>
+    <load name="openlog.xml"/>
+    <load name="nav_survey_polygon.xml"/>
+    <load name="nav_line_border.xml"/>
+    <load name="nav_line.xml"/>
+    <load name="nav_smooth.xml"/>
+    <load name="nav_flower.xml"/>
+    <load name="nav_line_osam.xml"/>
+    <load name="nav_survey_poly_osam.xml"/>
+    <load name="nav_vertical_raster.xml"/>
+    <!--load name="nav_catapult.xml"/-->
+    <load name="nav_bungee_takeoff.xml"/>
+    <load name="infrared_adc.xml"/>
+  </modules>
+
+
+  <firmware name="setup">
+    <target name="tunnel"           board="tiny_1.1" />
+    <target name="usb_tunnel_0"     board="tiny_1.1" />
+    <target name="usb_tunnel_1"     board="tiny_1.1" />
+  </firmware>
+
+</airframe>
diff --git a/conf/firmwares/subsystems/fixedwing/fdm_jsbsim.makefile b/conf/firmwares/subsystems/fixedwing/fdm_jsbsim.makefile
index 20b6e7f..ec5552a 100644
--- a/conf/firmwares/subsystems/fixedwing/fdm_jsbsim.makefile
+++ b/conf/firmwares/subsystems/fixedwing/fdm_jsbsim.makefile
@@ -58,9 +58,9 @@ nps.srcs += $(NPSDIR)/nps_main.c                 \
        $(NPSDIR)/nps_radio_control.c             \
        $(NPSDIR)/nps_radio_control_joystick.c    \
        $(NPSDIR)/nps_radio_control_spektrum.c    \
-       $(NPSDIR)/nps_autopilot_fixedwing.c       \
+       $(NPSDIR)/nps_autopilot_remote.c       \
        $(NPSDIR)/nps_ivy_common.c                \
-       $(NPSDIR)/nps_ivy_fixedwing.c             \
+       $(NPSDIR)/nps_ivy_remote.c             \
        $(NPSDIR)/nps_flightgear.c                \
 
 
diff --git a/conf/firmwares/subsystems/shared/attitude_infrared.makefile b/conf/firmwares/subsystems/shared/attitude_infrared.makefile
new file mode 100644
index 0000000..6f51989
--- /dev/null
+++ b/conf/firmwares/subsystems/shared/attitude_infrared.makefile
@@ -0,0 +1,41 @@
+# attitude via IR sensors
+
+#
+# default values for tiny and twog are:
+# ADC_IR1    = ADC_1
+# ADC_IR2    = ADC_2
+# ADC_IR_TOP = ADC_0
+# ADC_IR_NB_SAMPLES = 16
+#
+# to change just redefine these before including this file
+#
+
+#
+# LPC only has one ADC
+#
+ifeq ($(ARCH), lpc21)
+ap.CFLAGS += -DADC_CHANNEL_IR1=$(ADC_IR1) -DUSE_$(ADC_IR1)
+ap.CFLAGS += -DADC_CHANNEL_IR2=$(ADC_IR2) -DUSE_$(ADC_IR2)
+ap.CFLAGS += -DADC_CHANNEL_IR_TOP=$(ADC_IR_TOP) -DUSE_$(ADC_IR_TOP)
+endif
+
+#
+# On STM32 let's hardwire infrared sensors to AD1 for now
+#
+ifeq ($(ARCH), stm32)
+ap.CFLAGS += -DUSE_AD1
+ap.CFLAGS += -DADC_CHANNEL_IR1=$(ADC_IR1_CHAN) -DUSE_AD1_$(ADC_IR1)
+ap.CFLAGS += -DADC_CHANNEL_IR2=$(ADC_IR2_CHAN) -DUSE_AD1_$(ADC_IR2)
+ap.CFLAGS += -DADC_CHANNEL_IR_TOP=$(ADC_IR_TOP_CHAN) -DUSE_AD1_$(ADC_IR_TOP)
+endif
+
+ap.CFLAGS += -DADC_CHANNEL_IR_NB_SAMPLES=$(ADC_IR_NB_SAMPLES)
+
+$(TARGET).CFLAGS += -DUSE_INFRARED
+$(TARGET).srcs += subsystems/sensors/infrared.c
+$(TARGET).srcs += subsystems/sensors/infrared_adc.c
+
+sim.srcs += $(SRC_ARCH)/sim_ir.c
+
+# is already added to sources in autopilot.makefile
+#jsbsim.srcs += $(SRC_ARCH)/jsbsim_ir.c
diff --git a/conf/flight_plans/basic_old.xml b/conf/flight_plans/basic_old.xml
new file mode 100644
index 0000000..343446b
--- /dev/null
+++ b/conf/flight_plans/basic_old.xml
@@ -0,0 +1,93 @@
+<!DOCTYPE flight_plan SYSTEM "flight_plan.dtd">
+
+<flight_plan alt="75" ground_alt="0" lat0="43.46223" lon0="1.27289" max_dist_from_home="1500" name="Basic" security_height="25">
+  <header>
+<!--#include "subsystems/navigation/nav_line.h"/-->
+<!--#include "datalink.h"/-->
+#include "subsystems/datalink/datalink.h"
+</header>
+  <waypoints>
+    <waypoint name="HOME" x="0" y="0"/>
+    <waypoint name="STDBY" x="49.5" y="100.1"/>
+    <waypoint name="1" x="10.1" y="189.9"/>
+    <waypoint name="2" x="132.3" y="139.1"/>
+    <waypoint name="MOB" x="137.0" y="-11.6"/>
+    <waypoint name="S1" x="-119.2" y="69.6"/>
+    <waypoint name="S2" x="274.4" y="209.5"/>
+    <waypoint alt="30.0" name="AF" x="177.4" y="45.1"/>
+    <waypoint alt="0.0" name="TD" x="28.8" y="57.0"/>
+    <waypoint name="_BASELEG" x="168.8" y="-13.8"/>
+    <waypoint name="CLIMB" x="-114.5" y="162.3"/>
+  </waypoints>
+  <exceptions>
+    <!--exception cond="datalink_time > 22" deroute="Standby"/-->
+  </exceptions>
+  <blocks>
+    <block name="Wait GPS">
+      <set value="1" var="kill_throttle"/>
+      <while cond="!GpsFixValid()"/>
+    </block>
+    <block name="Geo init">
+      <while cond="LessThan(NavBlockTime(), 10)"/>
+      <call fun="NavSetGroundReferenceHere()"/>
+    </block>
+    <block name="Holding point">
+      <!--set var="nav_mode" value="NAV_MODE_ROLL"/-->
+      <set value="1" var="kill_throttle"/>
+      <attitude roll="0" throttle="0" vmode="throttle"/>
+    </block>
+    <block key="t" name="Takeoff" strip_button="Takeoff (wp CLIMB)" strip_icon="takeoff.png" group="home">
+      <exception cond="GetPosAlt() > ground_alt+25" deroute="Standby"/>
+      <set value="0" var="kill_throttle"/>
+      <set value="0" var="autopilot_flight_time"/>
+      <go from="HOME" throttle="1.0" vmode="throttle" wp="CLIMB" pitch="15"/>
+    </block>
+    <block key="Ctrl+a" name="Standby" strip_button="Standby" strip_icon="home.png" group="home">
+      <circle radius="nav_radius" wp="STDBY"/>
+    </block>
+    <block key="F8" name="Figure 8 around wp 1" strip_button="Figure 8 (wp 1-2)" strip_icon="eight.png" group="base_pattern">
+      <eight center="1" radius="nav_radius" turn_around="2"/>
+    </block>
+    <block name="Oval 1-2" strip_button="Oval (wp 1-2)" strip_icon="oval.png" group="base_pattern">
+      <oval p1="1" p2="2" radius="nav_radius"/>
+    </block>
+    <block name="MOB" strip_button="Turn around here" strip_icon="mob.png" group="base_pattern">
+      <call fun="NavSetWaypointHere(WP_MOB)"/>
+      <set value="DEFAULT_CIRCLE_RADIUS" var="nav_radius"/>
+      <circle radius="nav_radius" wp="MOB"/>
+    </block>
+    <!--block name="Line 1-2" strip_button="Line (wp 1-2)" strip_icon="line.png" group="extra_pattern">
+      <call fun="nav_line_init()"/>
+      <call fun="nav_line(WP_1, WP_2, nav_radius)"/>
+    </block-->
+    <block name="Survey S1-S2" strip_button="Survey (wp S1-S2)" strip_icon="survey.png" group="extra_pattern">
+      <survey_rectangle grid="150" wp1="S1" wp2="S2"/>
+    </block>
+    <block name="Path 1,2,S1,S2,STDBY" strip_button="Path (1,2,S1,S2,STDBY)" strip_icon="path.png" group="extra_pattern">
+      <path wpts="1,2 S1"/>
+      <path wpts="S1, S2 STDBY" approaching_time="1" pitch="auto" throttle="0.4"/>
+      <deroute block="Standby"/>
+    </block>
+    <block name="Land Right AF-TD" strip_button="Land right (wp AF-TD)" strip_icon="land-right.png" group="land">
+      <set value="DEFAULT_CIRCLE_RADIUS" var="nav_radius"/>
+      <deroute block="land"/>
+    </block>
+    <block name="Land Left AF-TD" strip_button="Land left (wp AF-TD)" strip_icon="land-left.png" group="land">
+      <set value="-DEFAULT_CIRCLE_RADIUS" var="nav_radius"/>
+      <deroute block="land"/>
+    </block>
+    <block name="land">
+      <call fun="nav_compute_baseleg(WP_AF, WP_TD, WP__BASELEG, nav_radius)"/>
+      <circle radius="nav_radius" until="NavCircleCount() > 0.5" wp="_BASELEG"/>
+      <circle radius="nav_radius" until="And(NavQdrCloseTo(DegOfRad(baseleg_out_qdr)-(nav_radius/fabs(nav_radius))*10), 10 > fabs(GetPosAlt() - WaypointAlt(WP__BASELEG)))" wp="_BASELEG"/>
+    </block>
+    <block name="final">
+      <exception cond="ground_alt + 10 > GetPosAlt()" deroute="flare"/>
+      <go from="AF" hmode="route" vmode="glide" wp="TD"/>
+    </block>
+    <block name="flare">
+      <go approaching_time="0" from="AF" hmode="route" throttle="0.0" vmode="throttle" wp="TD"/>
+      <attitude roll="0.0" throttle="0.0" until="FALSE" vmode="throttle"/>
+    </block>
+  </blocks>
+</flight_plan>
diff --git a/conf/messages.xml b/conf/messages.xml
index ebdbe2a..4d58cd8 100644
--- a/conf/messages.xml
+++ b/conf/messages.xml
@@ -2131,6 +2131,12 @@
   </message>
 
   <!-- 251 is free -->
+  <message name="NPS_ATP_CMD" id="251">
+    <field name="yaw"    type="int16" />
+    <field name="roll"    type="int16" />
+    <field name="pitch"   type="int16" />
+    <field name="throttle"       type="int16" />
+  </message>
   <!-- 252 is free -->
 
   <message name="I2C_ERRORS" id="253">
@@ -2791,4 +2797,6 @@
 
 
 
+
+
 </protocol>
diff --git a/conf/settings/basic_infrared.xml b/conf/settings/basic_infrared.xml
new file mode 100644
index 0000000..2546193
--- /dev/null
+++ b/conf/settings/basic_infrared.xml
@@ -0,0 +1,33 @@
+<!DOCTYPE settings SYSTEM "settings.dtd">
+
+<!-- A conf to use for standard operation with IR sensors (no tuning) -->
+
+<settings>
+  <dl_settings>
+    <dl_settings NAME="flight params">
+      <dl_setting MAX="1000" MIN="0" STEP="10" VAR="flight_altitude" shortname="altitude"/>
+      <dl_setting MAX="360" MIN="0" STEP="1" VAR="nav_course"/>
+      <dl_setting MAX="10" MIN="-10" STEP="5" VAR="nav_shift" module="subsystems/nav" handler="IncreaseShift" shortname="inc. shift"/>
+      <dl_setting MAX="0" MIN="0" STEP="1" VAR="autopilot_flight_time" shortname="flight time" module="autopilot" handler="ResetFlightTimeAndLaunch"/>
+      <dl_setting MAX="200" MIN="-200" STEP="10" VAR="nav_radius" module="subsystems/nav" handler="SetNavRadius">
+        <strip_button icon="circle-right.png" name="Circle right" value="1"/>
+        <strip_button icon="circle-left.png" name="Circle left" value="-1"/>
+        <key_press key="greater" value="1"/>
+        <key_press key="less" value="-1"/>
+      </dl_setting>
+    </dl_settings>
+
+    <dl_settings NAME="mode">
+      <dl_setting MAX="2" MIN="0" STEP="1" VAR="pprz_mode" module="autopilot" values="MANUAL|AUTO1|AUTO2|HOME|NOGPS|FAILSAFE"/>
+      <dl_setting MAX="1" MIN="0" STEP="1" VAR="launch"/>
+      <dl_setting MAX="1" MIN="0" STEP="1" VAR="kill_throttle"/>
+      <!--dl_setting MAX="2" MIN="0" STEP="1" VAR="telemetry_mode_Ap_DefaultChannel" shortname="tele_AP" module="subsystems/datalink/downlink" values="Default|Minimal|Extremal"/-->
+      <dl_setting MAX="2" MIN="0" STEP="1" VAR="gps.reset" module="subsystems/gps" handler="Reset" shortname="GPS reset"/>
+    </dl_settings>
+
+    <dl_settings NAME="Infrared">
+        <dl_setting MAX="15" MIN="-15" STEP="1" VAR="infrared.roll_neutral" shortname="roll neutral" module="subsystems/sensors/infrared" param="IR_ROLL_NEUTRAL_DEFAULT" unit="rad" alt_unit="deg" alt_unit_coef="57.3"/>
+        <dl_setting MAX="0.5" MIN="-0.3" STEP="0.01" VAR="infrared.pitch_neutral" shortname="pitch neutral" module="subsystems/sensors/infrared" param="IR_PITCH_NEUTRAL_DEFAULT" unit="rad"/>
+    </dl_settings>
+  </dl_settings>
+</settings>
diff --git a/sw/simulator/nps/nps_autopilot_fixedwing.c b/sw/simulator/nps/nps_autopilot_fixedwing.c
index 08056cf..b1abc72 100644
--- a/sw/simulator/nps/nps_autopilot_fixedwing.c
+++ b/sw/simulator/nps/nps_autopilot_fixedwing.c
@@ -64,28 +64,27 @@ bool_t nps_bypass_ins;
 #define NPS_BYPASS_INS FALSE
 #endif
 
-
 #if !defined (FBW) || !defined (AP)
 #error NPS does not currently support dual processor simulation for FBW and AP on fixedwing!
 #endif
 
-void nps_autopilot_init(enum NpsRadioControlType type_rc, int num_rc_script, char* rc_dev) {
+void nps_autopilot_init(enum NpsRadioControlType type_rc, int num_rc_script,
+		char* rc_dev) {
 
-  autopilot.launch = FALSE;
+	autopilot.launch = FALSE;
 
-  nps_radio_control_init(type_rc, num_rc_script, rc_dev);
-  nps_electrical_init();
+	nps_radio_control_init(type_rc, num_rc_script, rc_dev);
+	nps_electrical_init();
 
-  nps_bypass_ahrs = NPS_BYPASS_AHRS;
-  nps_bypass_ins = NPS_BYPASS_INS;
+	nps_bypass_ahrs = NPS_BYPASS_AHRS;
+	nps_bypass_ins = NPS_BYPASS_INS;
 
-  Fbw(init);
-  Ap(init);
+	Fbw(init); Ap(init);
 
 }
 
-void nps_autopilot_run_systime_step( void ) {
-  sys_tick_handler();
+void nps_autopilot_run_systime_step(void) {
+	sys_tick_handler();
 }
 
 #include <stdio.h>
@@ -93,88 +92,84 @@ void nps_autopilot_run_systime_step( void ) {
 
 void nps_autopilot_run_step(double time) {
 
-  nps_electrical_run_step(time);
+	nps_electrical_run_step(time);
 
 #ifdef RADIO_CONTROL_TYPE_PPM
-  if (nps_radio_control_available(time)) {
-    radio_control_feed();
-    Fbw(event_task);
-  }
+	if (nps_radio_control_available(time)) {
+		radio_control_feed();
+		Fbw(event_task);
+	}
 #endif
 
-  if (nps_sensors_gyro_available()) {
-    imu_feed_gyro_accel();
-    Fbw(event_task);
-    Ap(event_task);
-  }
-
-  if (nps_sensors_mag_available()) {
-    imu_feed_mag();
-    Fbw(event_task);
-    Ap(event_task);
- }
-
-  if (nps_sensors_baro_available()) {
-    float pressure = (float) sensors.baro.value;
-    AbiSendMsgBARO_ABS(BARO_SIM_SENDER_ID, &pressure);
-    Fbw(event_task);
-    Ap(event_task);
-  }
-
-  if (nps_sensors_gps_available()) {
-    gps_feed_value();
-    Fbw(event_task);
-    Ap(event_task);
-  }
-
-  if (nps_bypass_ahrs) {
-    sim_overwrite_ahrs();
-  }
-
-  if (nps_bypass_ins) {
-    sim_overwrite_ins();
-  }
-
-  Fbw(handle_periodic_tasks);
-  Ap(handle_periodic_tasks);
-
-  /* scale final motor commands to 0-1 for feeding the fdm */
-  for (uint8_t i=0; i < NPS_COMMANDS_NB; i++)
-    autopilot.commands[i] = (double)commands[i]/MAX_PPRZ;
-  // hack: invert pitch to fit most JSBSim models
-  autopilot.commands[COMMAND_PITCH] = -(double)commands[COMMAND_PITCH]/MAX_PPRZ;
-
-  // do the launch when clicking launch in GCS
-  autopilot.launch = launch && !kill_throttle;
-  if (!launch)
-    autopilot.commands[COMMAND_THROTTLE] = 0;
+	if (nps_sensors_gyro_available()) {
+		imu_feed_gyro_accel();
+		Fbw(event_task); Ap(event_task);
+	}
+
+	if (nps_sensors_mag_available()) {
+		imu_feed_mag();
+		Fbw(event_task); Ap(event_task);
+	}
+
+	if (nps_sensors_baro_available()) {
+		float pressure = (float) sensors.baro.value;
+		AbiSendMsgBARO_ABS(BARO_SIM_SENDER_ID, &pressure);
+		Fbw(event_task); Ap(event_task);
+	}
+
+	if (nps_sensors_gps_available()) {
+		gps_feed_value();
+		Fbw(event_task); Ap(event_task);
+	}
+
+	if (nps_bypass_ahrs) {
+		sim_overwrite_ahrs();
+	}
+
+	if (nps_bypass_ins) {
+		sim_overwrite_ins();
+	}
+
+	Fbw(handle_periodic_tasks); Ap(handle_periodic_tasks);
+
+	/* scale final motor commands to 0-1 for feeding the fdm */
+	for (uint8_t i = 0; i < NPS_COMMANDS_NB; i++)
+		autopilot.commands[i] = (double) commands[i] / MAX_PPRZ;
+	// hack: invert pitch to fit most JSBSim models
+	autopilot.commands[COMMAND_PITCH] = -(double) commands[COMMAND_PITCH]
+			/ MAX_PPRZ;
+
+	// do the launch when clicking launch in GCS
+	autopilot.launch = launch && !kill_throttle;
+	if (!launch)
+		autopilot.commands[COMMAND_THROTTLE] = 0;
 
 }
 
 void sim_overwrite_ahrs(void) {
 
-  struct FloatQuat quat_f;
-  QUAT_COPY(quat_f, fdm.ltp_to_body_quat);
-  stateSetNedToBodyQuat_f(&quat_f);
+	struct FloatQuat quat_f;
+	QUAT_COPY(quat_f, fdm.ltp_to_body_quat);
+	stateSetNedToBodyQuat_f(&quat_f);
 
-  struct FloatRates rates_f;
-  RATES_COPY(rates_f, fdm.body_ecef_rotvel);
-  stateSetBodyRates_f(&rates_f);
+	struct FloatRates rates_f;
+	RATES_COPY(rates_f, fdm.body_ecef_rotvel);
+	stateSetBodyRates_f(&rates_f);
 
 }
 
 void sim_overwrite_ins(void) {
 
-  struct NedCoor_f ltp_pos;
-  VECT3_COPY(ltp_pos, fdm.ltpprz_pos);
-  stateSetPositionNed_f(&ltp_pos);
+	struct NedCoor_f ltp_pos;
+	VECT3_COPY(ltp_pos, fdm.ltpprz_pos);
+	stateSetPositionNed_f(&ltp_pos);
 
-  struct NedCoor_f ltp_speed;
-  VECT3_COPY(ltp_speed, fdm.ltpprz_ecef_vel);
-  stateSetSpeedNed_f(&ltp_speed);
+	struct NedCoor_f ltp_speed;
+	VECT3_COPY(ltp_speed, fdm.ltpprz_ecef_vel);
+	stateSetSpeedNed_f(&ltp_speed);
 
-  struct NedCoor_f ltp_accel;
-  VECT3_COPY(ltp_accel, fdm.ltpprz_ecef_accel);
-  stateSetAccelNed_f(&ltp_accel);
+	struct NedCoor_f ltp_accel;
+	VECT3_COPY(ltp_accel, fdm.ltpprz_ecef_accel);
+	stateSetAccelNed_f(&ltp_accel);
 
 }
diff --git a/sw/simulator/nps/nps_autopilot_remote.c b/sw/simulator/nps/nps_autopilot_remote.c
new file mode 100644
index 0000000..0d8ca89
--- /dev/null
+++ b/sw/simulator/nps/nps_autopilot_remote.c
@@ -0,0 +1,203 @@
+/*
+ * Copyright (C) 2009 Shaun Cosgrove <shaun.cosgrove@bogglingtech.com>
+ * nps_autopilot_remote.c
+ *
+ *  Created on: May 22, 2014
+ *      Author: j3
+ */
+
+#include "nps_autopilot.h"
+
+#ifdef FBW
+#include "firmwares/fixedwing/main_fbw.h"
+#define Fbw(f) f ## _fbw()
+#else
+#define Fbw(f)
+#endif
+
+#ifdef AP
+#include "firmwares/fixedwing/main_ap.h"
+#define Ap(f) f ## _ap()
+#else
+#define Ap(f)
+#endif
+
+#include "nps_sensors.h"
+#include "nps_radio_control.h"
+#include "nps_electrical.h"
+#include "nps_fdm.h"
+
+#include "subsystems/radio_control.h"
+#include "subsystems/imu.h"
+#include "mcu_periph/sys_time.h"
+#include "state.h"
+#include "subsystems/commands.h"
+
+#include "subsystems/abi.h"
+
+// for launch
+#include "firmwares/fixedwing/autopilot.h"
+
+// For auto pilot communication
+#include <stdlib.h>
+#include <Ivy/ivy.h>
+#include <Ivy/ivyglibloop.h>
+
+struct NpsAutopilot autopilot;
+bool_t nps_bypass_ahrs;
+bool_t nps_bypass_ins;
+
+#ifndef NPS_BYPASS_AHRS
+#define NPS_BYPASS_AHRS FALSE
+#endif
+
+#ifndef NPS_BYPASS_INS
+#define NPS_BYPASS_INS FALSE
+#endif
+
+#if !defined (FBW) || !defined (AP)
+#error NPS does not currently support dual processor simulation for FBW and AP on fixedwing!
+#endif
+
+void nps_autopilot_init(enum NpsRadioControlType type_rc, int num_rc_script,
+		char* rc_dev) {
+
+	autopilot.launch = FALSE;
+
+	nps_radio_control_init(type_rc, num_rc_script, rc_dev);
+	nps_electrical_init();
+
+	nps_bypass_ahrs = NPS_BYPASS_AHRS;
+	nps_bypass_ins = NPS_BYPASS_INS;
+
+}
+
+void nps_autopilot_run_systime_step(void) {
+	sys_tick_handler();
+}
+
+//We are now able to pull out data directly from the simulator
+/*
+ double get_value(const char* name) {
+ return FDMExec->GetPropertyManager()->GetNode(name)->getDoubleValue();
+ }
+ */
+
+#include <stdio.h>
+#include "subsystems/gps.h"
+
+void nps_autopilot_run_step(double time) {
+//#define DegOfRad(x) ((x) * (180. / M_PI))
+
+	if (nps_sensors_gps_available()) {
+		gps_feed_value();
+
+		double vals[7];
+		nps_fdm_remote_position(&vals[0]);
+		IvySendMsg("NPS_SEN_NICE_GPS %d %d %f %f %f %f %f %f %f", 6, AC_ID,
+				vals[0], vals[1], vals[2], vals[3], vals[4], vals[5], vals[6]);
+		/*
+		 static double gps_period = 0.;
+		 #define DELTA_T (.0081447*1e-3)
+		 gps_period += DELTA_T;
+		 if (gps_period > GPS_PERIOD) {
+
+		 #define FT2M 0.3048
+		 double lat = get_value("position/lat-gc-rad");
+		 double lon = get_value("position/long-gc-rad");
+		 double alt = get_value("position/h-sl-meters");
+		 double course = get_value("attitude/heading-true-rad");
+		 double gspeed = get_value("velocities/vg-fps") * FT2M;
+		 double climb = get_value("velocities/v-down-fps") * (-FT2M);
+		 double time = get_value("simulation/sim-time-sec");
+
+		 gps_period = 0.;
+		 IvySendMsg("NPS_SEN_NICE_GPS %d %d %f %f %f %f %f %f", 6, AC_ID,
+		 lat, lon, alt, course, gspeed, climb, time);
+		 */
+		/* It may be better to pull the data from the fdm state, it will already be processed and ready to go...
+		 *
+		 */
+		//		IvySendMsg("NPS_SEN_NICE_GPS %d %d %f %f %f %f %f %f %f", 6, AC_ID,
+		//				DegOfRad(fdm.lla_pos_pprz.lat), DegOfRad(fdm.lla_pos_pprz.lon), fdm.lla_pos_pprz.alt, gps.course,
+		//				gps.gspeed, 1.0, fdm.time);
+	}
+
+	if (nps_bypass_ahrs) {
+		sim_overwrite_ahrs();
+	}
+
+	if (nps_bypass_ins) {
+		sim_overwrite_ins();
+	}
+
+	//TODO Figure out when to send this data...
+	{
+		/*
+		 //print(FDMExec);
+		 double roll = get_value("attitude/roll-rad");
+		 double pitch = get_value("attitude/pitch-rad");
+		 double yaw = get_value("attitude/heading-true-rad");
+		 double p = get_value("velocities/p-rad_sec");
+		 double q = get_value("velocities/q-rad_sec");
+		 double r = get_value("velocities/r-rad_sec");
+
+		 IvySendMsg("NPS_SEN_NICE_IR %d %d %f %f %f %f %f %f", 6, AC_ID, roll,
+		 pitch, yaw, p, q, r);
+		 */
+		//It may be better to get the pose data from the fdm state ... decide in future
+		/*
+		 *
+		 */
+//		IvySendMsg("NPS_SEN_NICE_IR %d %d %f %f %f %f %f %f", 6, AC_ID,
+//				fdm.ltp_to_body_eulers.phi, fdm.ltp_to_body_eulers.theta,
+//				fdm.ltp_to_body_eulers.psi, fdm.body_ecef_rotvel.p,
+//				fdm.body_ecef_rotvel.q, fdm.body_ecef_rotvel.r);
+		double ir[6];
+		nps_fdm_remote_ir(&ir[0]);
+		IvySendMsg("NPS_SEN_NICE_IR %d %d %f %f %f %f %f %f", 6, AC_ID, ir[0],
+				ir[1], ir[2], ir[3], ir[4], ir[5]);
+	}
+
+	//Stuff the commands from the autopilot into the buffer here
+	/* scale final motor commands to 0-1 for feeding the fdm */
+	for (uint8_t i = 0; i < NPS_COMMANDS_NB; i++)
+		autopilot.commands[i] = (double) commands[i] / MAX_PPRZ;
+	// hack: invert pitch to fit most JSBSim models
+	autopilot.commands[COMMAND_PITCH] = -(double) commands[COMMAND_PITCH]
+			/ MAX_PPRZ;
+
+	// do the launch when clicking launch in GCS
+	autopilot.launch = launch && !kill_throttle;
+	if (!launch)
+		autopilot.commands[COMMAND_THROTTLE] = 0;
+
+}
+
+void sim_overwrite_ahrs(void) {
+
+	struct FloatQuat quat_f;
+	QUAT_COPY(quat_f, fdm.ltp_to_body_quat);
+	stateSetNedToBodyQuat_f(&quat_f);
+
+	struct FloatRates rates_f;
+	RATES_COPY(rates_f, fdm.body_ecef_rotvel);
+	stateSetBodyRates_f(&rates_f);
+
+}
+
+void sim_overwrite_ins(void) {
+
+	struct NedCoor_f ltp_pos;
+	VECT3_COPY(ltp_pos, fdm.ltpprz_pos);
+	stateSetPositionNed_f(&ltp_pos);
+
+	struct NedCoor_f ltp_speed;
+	VECT3_COPY(ltp_speed, fdm.ltpprz_ecef_vel);
+	stateSetSpeedNed_f(&ltp_speed);
+
+	struct NedCoor_f ltp_accel;
+	VECT3_COPY(ltp_accel, fdm.ltpprz_ecef_accel);
+	stateSetAccelNed_f(&ltp_accel);
+
+}
diff --git a/sw/simulator/nps/nps_fdm.h b/sw/simulator/nps/nps_fdm.h
index 77e6098..04a0791 100644
--- a/sw/simulator/nps/nps_fdm.h
+++ b/sw/simulator/nps/nps_fdm.h
@@ -22,71 +22,77 @@
 #ifndef NPS_FDM
 #define NPS_FDM
 
+#include <FGFDMExec.h>
+#include <FGJSBBase.h>
+#include <models/FGPropulsion.h>
+#include <models/FGGroundReactions.h>
+#include <models/FGAccelerations.h>
+#include <models/atmosphere/FGWinds.h>
 
 #include "std.h"
 #include "math/pprz_geodetic_double.h"
 #include "math/pprz_algebra_double.h"
 
 /*
-  Notations for fdm variables
-  ---------------------------
-  coordinate system [ frame ] name
+ Notations for fdm variables
+ ---------------------------
+ coordinate system [ frame ] name
 
-  ecef_inertial_vel is the time derivative of position
-  with respect to inertial frame expressed in ECEF ( Earth Centered Earth Fixed)
-  coordinate system.
-*/
+ ecef_inertial_vel is the time derivative of position
+ with respect to inertial frame expressed in ECEF ( Earth Centered Earth Fixed)
+ coordinate system.
+ */
 
 struct NpsFdm {
 
-  double time;
-  double init_dt;
-  double curr_dt;
-  bool_t on_ground;
-  int nan_count;
-
-  /*  position */
-  struct EcefCoor_d  ecef_pos;
-  struct NedCoor_d ltpprz_pos;
-  struct LlaCoor_d lla_pos;
-  double hmsl;
-  // for debugging
-  struct LlaCoor_d lla_pos_pprz; //lla converted by pprz from ecef
-  struct LlaCoor_d lla_pos_geod; //geodetic lla from jsbsim
-  struct LlaCoor_d lla_pos_geoc; //geocentric lla from jsbsim
-  double agl; //AGL from jsbsim in m
-
-  /*  velocity and acceleration wrt inertial frame expressed in ecef frame */
-  //  struct EcefCoor_d  ecef_inertial_vel;
-  //  struct EcefCoor_d  ecef_inertial_accel;
-  /*  velocity and acceleration wrt ecef frame expressed in ecef frame     */
-  struct EcefCoor_d  ecef_ecef_vel;
-  struct EcefCoor_d  ecef_ecef_accel;
-  /*  velocity and acceleration wrt ecef frame expressed in body frame     */
-  struct DoubleVect3 body_ecef_vel;   /* aka UVW */
-  struct DoubleVect3 body_ecef_accel;
-  /*  velocity and acceleration wrt ecef frame expressed in ltp frame     */
-  struct NedCoor_d ltp_ecef_vel;
-  struct NedCoor_d ltp_ecef_accel;
-  /*  velocity and acceleration wrt ecef frame expressed in ltppprz frame */
-  struct NedCoor_d ltpprz_ecef_vel;
-  struct NedCoor_d ltpprz_ecef_accel;
-
-  /* attitude */
-  struct DoubleQuat   ecef_to_body_quat;
-  struct DoubleQuat   ltp_to_body_quat;
-  struct DoubleEulers ltp_to_body_eulers;
-  struct DoubleQuat   ltpprz_to_body_quat;
-  struct DoubleEulers ltpprz_to_body_eulers;
-
-  /*  velocity and acceleration wrt ecef frame expressed in body frame     */
-  struct DoubleRates  body_ecef_rotvel;
-  struct DoubleRates  body_ecef_rotaccel;
-
-  struct DoubleVect3 ltp_g;
-  struct DoubleVect3 ltp_h;
-
-  struct DoubleVect3 wind; ///< velocity in m/s in NED
+	double time;
+	double init_dt;
+	double curr_dt;
+	bool_t on_ground;
+	int nan_count;
+
+	/*  position */
+	struct EcefCoor_d ecef_pos;
+	struct NedCoor_d ltpprz_pos;
+	struct LlaCoor_d lla_pos;
+	double hmsl;
+	// for debugging
+	struct LlaCoor_d lla_pos_pprz; //lla converted by pprz from ecef
+	struct LlaCoor_d lla_pos_geod; //geodetic lla from jsbsim
+	struct LlaCoor_d lla_pos_geoc; //geocentric lla from jsbsim
+	double agl; //AGL from jsbsim in m
+
+	/*  velocity and acceleration wrt inertial frame expressed in ecef frame */
+	//  struct EcefCoor_d  ecef_inertial_vel;
+	//  struct EcefCoor_d  ecef_inertial_accel;
+	/*  velocity and acceleration wrt ecef frame expressed in ecef frame     */
+	struct EcefCoor_d ecef_ecef_vel;
+	struct EcefCoor_d ecef_ecef_accel;
+	/*  velocity and acceleration wrt ecef frame expressed in body frame     */
+	struct DoubleVect3 body_ecef_vel; /* aka UVW */
+	struct DoubleVect3 body_ecef_accel;
+	/*  velocity and acceleration wrt ecef frame expressed in ltp frame     */
+	struct NedCoor_d ltp_ecef_vel;
+	struct NedCoor_d ltp_ecef_accel;
+	/*  velocity and acceleration wrt ecef frame expressed in ltppprz frame */
+	struct NedCoor_d ltpprz_ecef_vel;
+	struct NedCoor_d ltpprz_ecef_accel;
+
+	/* attitude */
+	struct DoubleQuat ecef_to_body_quat;
+	struct DoubleQuat ltp_to_body_quat;
+	struct DoubleEulers ltp_to_body_eulers;
+	struct DoubleQuat ltpprz_to_body_quat;
+	struct DoubleEulers ltpprz_to_body_eulers;
+
+	/*  velocity and acceleration wrt ecef frame expressed in body frame     */
+	struct DoubleRates body_ecef_rotvel;
+	struct DoubleRates body_ecef_rotaccel;
+
+	struct DoubleVect3 ltp_g;
+	struct DoubleVect3 ltp_h;
+
+	struct DoubleVect3 wind; ///< velocity in m/s in NED
 
 };
 
@@ -95,5 +101,7 @@ extern struct NpsFdm fdm;
 extern void nps_fdm_init(double dt);
 extern void nps_fdm_run_step(bool_t launch, double* commands, int commands_nb);
 extern void nps_fdm_set_wind(double speed, double dir, int turbulence_severity);
+extern void nps_fdm_remote_position(double* ptr);
+void nps_fdm_remote_ir(double * ptr);
 
 #endif /* NPS_FDM */
diff --git a/sw/simulator/nps/nps_fdm_jsbsim.c b/sw/simulator/nps/nps_fdm_jsbsim.c
index 19702fe..8bad30f 100644
--- a/sw/simulator/nps/nps_fdm_jsbsim.c
+++ b/sw/simulator/nps/nps_fdm_jsbsim.c
@@ -75,13 +75,18 @@ static void feed_jsbsim(double* commands, int commands_nb);
 static void fetch_state(void);
 static int check_for_nan(void);
 
-static void jsbsimvec_to_vec(DoubleVect3* fdm_vector, const FGColumnVector3* jsb_vector);
-static void jsbsimloc_to_loc(EcefCoor_d* fdm_location, const FGLocation* jsb_location);
-static void jsbsimquat_to_quat(DoubleQuat* fdm_quat, const FGQuaternion* jsb_quat);
-static void jsbsimvec_to_rate(DoubleRates* fdm_rate, const FGColumnVector3* jsb_vector);
+static void jsbsimvec_to_vec(DoubleVect3* fdm_vector,
+		const FGColumnVector3* jsb_vector);
+static void jsbsimloc_to_loc(EcefCoor_d* fdm_location,
+		const FGLocation* jsb_location);
+static void jsbsimquat_to_quat(DoubleQuat* fdm_quat,
+		const FGQuaternion* jsb_quat);
+static void jsbsimvec_to_rate(DoubleRates* fdm_rate,
+		const FGColumnVector3* jsb_vector);
 static void llh_from_jsbsim(LlaCoor_d* fdm_lla, FGPropagate* propagate);
 static void lla_from_jsbsim_geodetic(LlaCoor_d* fdm_lla, FGPropagate* propagate);
-static void lla_from_jsbsim_geocentric(LlaCoor_d* fdm_lla, FGPropagate* propagate);
+static void lla_from_jsbsim_geocentric(LlaCoor_d* fdm_lla,
+		FGPropagate* propagate);
 
 static void init_jsbsim(double dt);
 static void init_ltp(void);
@@ -105,106 +110,114 @@ double min_dt;
 
 void nps_fdm_init(double dt) {
 
-  fdm.init_dt = dt;
-  fdm.curr_dt = dt;
-  //Sets up the high fidelity timestep as a multiple of the normal timestep
-  for (min_dt = (1.0/dt); min_dt < (1/MIN_DT); min_dt += (1/dt)){}
-  min_dt = (1/min_dt);
+	fdm.init_dt = dt;
+	fdm.curr_dt = dt;
+	//Sets up the high fidelity timestep as a multiple of the normal timestep
+	for (min_dt = (1.0 / dt); min_dt < (1 / MIN_DT); min_dt += (1 / dt)) {
+	}
+	min_dt = (1 / min_dt);
 
-  fdm.nan_count = 0;
+	fdm.nan_count = 0;
 
-  VECT3_ASSIGN(offset, 0., 0., 0.);
+	VECT3_ASSIGN(offset, 0., 0., 0.);
 
-  init_jsbsim(dt);
+	init_jsbsim(dt);
 
-  FDMExec->RunIC();
+	FDMExec->RunIC();
 
-  init_ltp();
+	init_ltp();
 
 #if DEBUG_NPS_JSBSIM
-  printf("fdm.time,fg_body_ecef_accel1,fg_body_ecef_accel2,fg_body_ecef_accel3,fdm.body_ecef_accel.x,fdm.body_ecef_accel.y,fdm.body_ecef_accel.z,fg_ltp_ecef_accel1,fg_ltp_ecef_accel2,fg_ltp_ecef_accel3,fdm.ltp_ecef_accel.x,fdm.ltp_ecef_accel.y,fdm.ltp_ecef_accel.z,fg_ecef_ecef_accel1,fg_ecef_ecef_accel2,fg_ecef_ecef_accel3,fdm.ecef_ecef_accel.x,fdm.ecef_ecef_accel.y,fdm.ecef_ecef_accel.z,fdm.ltpprz_ecef_accel.z,fdm.ltpprz_ecef_accel.y,fdm.ltpprz_ecef_accel.z,fdm.agl\n");
+	printf(
+			"fdm.time,fg_body_ecef_accel1,fg_body_ecef_accel2,fg_body_ecef_accel3,fdm.body_ecef_accel.x,fdm.body_ecef_accel.y,fdm.body_ecef_accel.z,fg_ltp_ecef_accel1,fg_ltp_ecef_accel2,fg_ltp_ecef_accel3,fdm.ltp_ecef_accel.x,fdm.ltp_ecef_accel.y,fdm.ltp_ecef_accel.z,fg_ecef_ecef_accel1,fg_ecef_ecef_accel2,fg_ecef_ecef_accel3,fdm.ecef_ecef_accel.x,fdm.ecef_ecef_accel.y,fdm.ecef_ecef_accel.z,fdm.ltpprz_ecef_accel.z,fdm.ltpprz_ecef_accel.y,fdm.ltpprz_ecef_accel.z,fdm.agl\n");
 #endif
 
-  fetch_state();
+	fetch_state();
 
 }
 
 void nps_fdm_run_step(bool_t launch, double* commands, int commands_nb) {
-  static bool_t run_model = FALSE;
+	static bool_t run_model = FALSE;
 
-  if (launch && !run_model) {
-    run_model = TRUE;
+	if (launch && !run_model) {
+		run_model = TRUE;
 #ifdef NPS_JSBSIM_LAUNCHSPEED
-    printf("Launching with speed of %.1f m/s!\n", (float)NPS_JSBSIM_LAUNCHSPEED);
-    FDMExec->GetIC()->SetUBodyFpsIC(FeetOfMeters(NPS_JSBSIM_LAUNCHSPEED));
+		printf("Launching with speed of %.1f m/s!\n", (float)NPS_JSBSIM_LAUNCHSPEED);
+		FDMExec->GetIC()->SetUBodyFpsIC(FeetOfMeters(NPS_JSBSIM_LAUNCHSPEED));
 #endif
-    FDMExec->RunIC();
-  }
-
-  if (run_model) {
-    feed_jsbsim(commands, commands_nb);
-
-    /* To deal with ground interaction issues, we decrease the time
-       step as the vehicle is close to the ground. This is done predictively
-       to ensure no weird accelerations or oscillations. From tests with a bouncing
-       ball model in JSBSim, it seems that 10k steps per second is reasonable to capture
-       all the dynamics. Higher might be a bit more stable, but really starting to push
-       the simulation CPU requirements, especially for more complex models.
-       - at init: get the largest radius from CG to any contact point (landing gear)
-       - if descending...
-       - find current number of timesteps to impact
-       - if impact imminent, calculate a new timestep to use (with limit)
-       - if ascending...
-       - change timestep back to init value
-       - run sim for as many steps as needed to reach init_dt amount of time
-
-       Of course, could probably be improved...
-    */
-    // If the vehicle has a downwards velocity
-    if (fdm.ltp_ecef_vel.z > 0) {
-      // Get the current number of timesteps until impact at current velocity
-      double numDT_to_impact = (fdm.agl - vehicle_radius_max) / (fdm.curr_dt * fdm.ltp_ecef_vel.z);
-      // If impact imminent within next timestep, use high sim rate
-      if (numDT_to_impact <= 1.0) {
-        fdm.curr_dt = min_dt;
-      }
-    }
-    // If the vehicle is moving upwards and out of the ground, reset timestep
-    else if ((fdm.ltp_ecef_vel.z <= 0) && ((fdm.agl + vehicle_radius_max) > 0)) {
-      fdm.curr_dt = fdm.init_dt;
-    }
-
-    // Calculate the number of sim steps for correct amount of time elapsed
-    int num_steps = int(fdm.init_dt / fdm.curr_dt);
-
-    // Set the timestep then run sim
-    FDMExec->Setdt(fdm.curr_dt);
-    int i;
-    for (i = 0; i < num_steps; i++) {
-      FDMExec->Run();
-    }
-  }
-
-  fetch_state();
-
-  /* Check the current state to make sure it is valid (no NaNs) */
-  if (check_for_nan()) {
-    printf("Error: FDM simulation encountered a total of %i NaN values at simulation time %f.\n", fdm.nan_count, fdm.time);
-    printf("It is likely the simulation diverged and gave non-physical results. If you did\n");
-    printf("not crash, check your model and/or initial conditions. Exiting with status 1.\n");
-    exit(1);
-  }
+		FDMExec->RunIC();
+	}
+
+	if (run_model) {
+		feed_jsbsim(commands, commands_nb);
+
+		/* To deal with ground interaction issues, we decrease the time
+		 step as the vehicle is close to the ground. This is done predictively
+		 to ensure no weird accelerations or oscillations. From tests with a bouncing
+		 ball model in JSBSim, it seems that 10k steps per second is reasonable to capture
+		 all the dynamics. Higher might be a bit more stable, but really starting to push
+		 the simulation CPU requirements, especially for more complex models.
+		 - at init: get the largest radius from CG to any contact point (landing gear)
+		 - if descending...
+		 - find current number of timesteps to impact
+		 - if impact imminent, calculate a new timestep to use (with limit)
+		 - if ascending...
+		 - change timestep back to init value
+		 - run sim for as many steps as needed to reach init_dt amount of time
+
+		 Of course, could probably be improved...
+		 */
+		// If the vehicle has a downwards velocity
+		if (fdm.ltp_ecef_vel.z > 0) {
+			// Get the current number of timesteps until impact at current velocity
+			double numDT_to_impact = (fdm.agl - vehicle_radius_max)
+					/ (fdm.curr_dt * fdm.ltp_ecef_vel.z);
+			// If impact imminent within next timestep, use high sim rate
+			if (numDT_to_impact <= 1.0) {
+				fdm.curr_dt = min_dt;
+			}
+		}
+		// If the vehicle is moving upwards and out of the ground, reset timestep
+		else if ((fdm.ltp_ecef_vel.z <= 0)
+				&& ((fdm.agl + vehicle_radius_max) > 0)) {
+			fdm.curr_dt = fdm.init_dt;
+		}
+
+		// Calculate the number of sim steps for correct amount of time elapsed
+		int num_steps = int(fdm.init_dt / fdm.curr_dt);
+
+		// Set the timestep then run sim
+		FDMExec->Setdt(fdm.curr_dt);
+		int i;
+		for (i = 0; i < num_steps; i++) {
+			FDMExec->Run();
+		}
+	}
+
+	fetch_state();
+
+	/* Check the current state to make sure it is valid (no NaNs) */
+	if (check_for_nan()) {
+		printf(
+				"Error: FDM simulation encountered a total of %i NaN values at simulation time %f.\n",
+				fdm.nan_count, fdm.time);
+		printf(
+				"It is likely the simulation diverged and gave non-physical results. If you did\n");
+		printf(
+				"not crash, check your model and/or initial conditions. Exiting with status 1.\n");
+		exit(1);
+	}
 
 }
 
 void nps_fdm_set_wind(double speed, double dir, int turbulence_severity) {
-  FGWinds* Winds = FDMExec->GetWinds();
-  Winds->SetWindspeed(FeetOfMeters(speed));
-  Winds->SetWindPsi(dir);
+	FGWinds* Winds = FDMExec->GetWinds();
+	Winds->SetWindspeed(FeetOfMeters(speed));
+	Winds->SetWindPsi(dir);
 
-  /* wind speed used for turbulence */
-  Winds->SetWindspeed20ft(FeetOfMeters(speed)/2);
-  Winds->SetProbabilityOfExceedence(turbulence_severity);
+	/* wind speed used for turbulence */
+	Winds->SetWindspeed20ft(FeetOfMeters(speed) / 2);
+	Winds->SetProbabilityOfExceedence(turbulence_severity);
 }
 
 /**
@@ -215,125 +228,149 @@ void nps_fdm_set_wind(double speed, double dir, int turbulence_severity) {
  */
 static void feed_jsbsim(double* commands, int commands_nb) {
 
-  char buf[64];
-  const char* names[] = NPS_ACTUATOR_NAMES;
-  string property;
+	char buf[64];
+	const char* names[] = NPS_ACTUATOR_NAMES;
+	string property;
 
-  int i;
-  for (i=0; i < commands_nb; i++) {
-    sprintf(buf,"fcs/%s",names[i]);
-    property = string(buf);
-    FDMExec->GetPropertyManager()->SetDouble(property,commands[i]);
-  }
+	int i;
+	for (i = 0; i < commands_nb; i++) {
+		sprintf(buf, "fcs/%s", names[i]);
+		property = string(buf);
+		FDMExec->GetPropertyManager()->SetDouble(property, commands[i]);
+	}
 
 }
 
-
 /**
  * Populates the NPS fdm struct after a simulation step.
  */
 static void fetch_state(void) {
 
-  FGPropertyManager* node = FDMExec->GetPropertyManager()->GetNode("simulation/sim-time-sec");
-  fdm.time = node->getDoubleValue();
+	FGPropertyManager* node = FDMExec->GetPropertyManager()->GetNode(
+			"simulation/sim-time-sec");
+	fdm.time = node->getDoubleValue();
 
 #if DEBUG_NPS_JSBSIM
-  printf("%f,",fdm.time);
+	printf("%f,", fdm.time);
 #endif
 
-  FGPropagate* propagate = FDMExec->GetPropagate();
-  FGAccelerations* accelerations = FDMExec->GetAccelerations();
+	FGPropagate* propagate = FDMExec->GetPropagate();
+	FGAccelerations* accelerations = FDMExec->GetAccelerations();
 
-  fdm.on_ground = FDMExec->GetGroundReactions()->GetWOW();
+	fdm.on_ground = FDMExec->GetGroundReactions()->GetWOW();
 
-  /*
-   * position
-   */
-  jsbsimloc_to_loc(&fdm.ecef_pos,&propagate->GetLocation());
-  fdm.hmsl = propagate->GetAltitudeASLmeters();
+	/*
+	 * position
+	 */
+	jsbsimloc_to_loc(&fdm.ecef_pos, &propagate->GetLocation());
+	fdm.hmsl = propagate->GetAltitudeASLmeters();
 
-  /*
-   * linear speed and accelerations
-   */
+	/*
+	 * linear speed and accelerations
+	 */
 
-  /* in body frame */
-  const FGColumnVector3& fg_body_ecef_vel = propagate->GetUVW();
-  jsbsimvec_to_vec(&fdm.body_ecef_vel, &fg_body_ecef_vel);
-  const FGColumnVector3& fg_body_ecef_accel = accelerations->GetUVWdot();
-  jsbsimvec_to_vec(&fdm.body_ecef_accel,&fg_body_ecef_accel);
+	/* in body frame */
+	const FGColumnVector3
+	&fg_body_ecef_vel = propagate->GetUVW();
+	jsbsimvec_to_vec(&fdm.body_ecef_vel, &fg_body_ecef_vel);
+	const FGColumnVector3
+	&fg_body_ecef_accel = accelerations->GetUVWdot();
+	jsbsimvec_to_vec(&fdm.body_ecef_accel, &fg_body_ecef_accel);
 
 #if DEBUG_NPS_JSBSIM
-  printf("%f,%f,%f,%f,%f,%f,",(&fg_body_ecef_accel)->Entry(1),(&fg_body_ecef_accel)->Entry(2),(&fg_body_ecef_accel)->Entry(3),fdm.body_ecef_accel.x,fdm.body_ecef_accel.y,fdm.body_ecef_accel.z);
+	printf("%f,%f,%f,%f,%f,%f,", (&fg_body_ecef_accel)->Entry(1),
+			(&fg_body_ecef_accel)->Entry(2), (&fg_body_ecef_accel)->Entry(3),
+			fdm.body_ecef_accel.x, fdm.body_ecef_accel.y,
+			fdm.body_ecef_accel.z);
 #endif
 
-  /* in LTP frame */
-  const FGMatrix33& body_to_ltp = propagate->GetTb2l();
-  const FGColumnVector3& fg_ltp_ecef_vel = body_to_ltp * fg_body_ecef_vel;
-  jsbsimvec_to_vec((DoubleVect3*)&fdm.ltp_ecef_vel, &fg_ltp_ecef_vel);
-  const FGColumnVector3& fg_ltp_ecef_accel = body_to_ltp * fg_body_ecef_accel;
-  jsbsimvec_to_vec((DoubleVect3*)&fdm.ltp_ecef_accel, &fg_ltp_ecef_accel);
+	/* in LTP frame */
+	const FGMatrix33
+	&body_to_ltp = propagate->GetTb2l();
+	const FGColumnVector3
+	&fg_ltp_ecef_vel = body_to_ltp * fg_body_ecef_vel;
+	jsbsimvec_to_vec((DoubleVect3*) &fdm.ltp_ecef_vel, &fg_ltp_ecef_vel);
+	const FGColumnVector3
+	&fg_ltp_ecef_accel = body_to_ltp * fg_body_ecef_accel;
+	jsbsimvec_to_vec((DoubleVect3*) &fdm.ltp_ecef_accel, &fg_ltp_ecef_accel);
 
 #if DEBUG_NPS_JSBSIM
-  printf("%f,%f,%f,%f,%f,%f,",(&fg_ltp_ecef_accel)->Entry(1),(&fg_ltp_ecef_accel)->Entry(2),(&fg_ltp_ecef_accel)->Entry(3),fdm.ltp_ecef_accel.x,fdm.ltp_ecef_accel.y,fdm.ltp_ecef_accel.z);
+	printf("%f,%f,%f,%f,%f,%f,", (&fg_ltp_ecef_accel)->Entry(1),
+			(&fg_ltp_ecef_accel)->Entry(2), (&fg_ltp_ecef_accel)->Entry(3),
+			fdm.ltp_ecef_accel.x, fdm.ltp_ecef_accel.y, fdm.ltp_ecef_accel.z);
 #endif
 
-  /* in ECEF frame */
-  const FGMatrix33& body_to_ecef = propagate->GetTb2ec();
-  const FGColumnVector3& fg_ecef_ecef_vel = body_to_ecef * fg_body_ecef_vel;
-  jsbsimvec_to_vec((DoubleVect3*)&fdm.ecef_ecef_vel, &fg_ecef_ecef_vel);
-  const FGColumnVector3& fg_ecef_ecef_accel = body_to_ecef * fg_body_ecef_accel;
-  jsbsimvec_to_vec((DoubleVect3*)&fdm.ecef_ecef_accel, &fg_ecef_ecef_accel);
+	/* in ECEF frame */
+	const FGMatrix33
+	&body_to_ecef = propagate->GetTb2ec();
+	const FGColumnVector3
+	&fg_ecef_ecef_vel = body_to_ecef * fg_body_ecef_vel;
+	jsbsimvec_to_vec((DoubleVect3*) &fdm.ecef_ecef_vel, &fg_ecef_ecef_vel);
+	const FGColumnVector3
+	&fg_ecef_ecef_accel = body_to_ecef * fg_body_ecef_accel;
+	jsbsimvec_to_vec((DoubleVect3*) &fdm.ecef_ecef_accel, &fg_ecef_ecef_accel);
 
 #if DEBUG_NPS_JSBSIM
-  printf("%f,%f,%f,%f,%f,%f,",(&fg_ecef_ecef_accel)->Entry(1),(&fg_ecef_ecef_accel)->Entry(2),(&fg_ecef_ecef_accel)->Entry(3),fdm.ecef_ecef_accel.x,fdm.ecef_ecef_accel.y,fdm.ecef_ecef_accel.z);
+	printf("%f,%f,%f,%f,%f,%f,", (&fg_ecef_ecef_accel)->Entry(1),
+			(&fg_ecef_ecef_accel)->Entry(2), (&fg_ecef_ecef_accel)->Entry(3),
+			fdm.ecef_ecef_accel.x, fdm.ecef_ecef_accel.y,
+			fdm.ecef_ecef_accel.z);
 #endif
 
-  /* in LTP pprz */
-  ned_of_ecef_point_d(&fdm.ltpprz_pos, &ltpdef, &fdm.ecef_pos);
-  ned_of_ecef_vect_d(&fdm.ltpprz_ecef_vel, &ltpdef, &fdm.ecef_ecef_vel);
-  ned_of_ecef_vect_d(&fdm.ltpprz_ecef_accel, &ltpdef, &fdm.ecef_ecef_accel);
+	/* in LTP pprz */
+	ned_of_ecef_point_d(&fdm.ltpprz_pos, &ltpdef, &fdm.ecef_pos);
+	ned_of_ecef_vect_d(&fdm.ltpprz_ecef_vel, &ltpdef, &fdm.ecef_ecef_vel);
+	ned_of_ecef_vect_d(&fdm.ltpprz_ecef_accel, &ltpdef, &fdm.ecef_ecef_accel);
 
 #if DEBUG_NPS_JSBSIM
-  printf("%f,%f,%f,",fdm.ltpprz_ecef_accel.z,fdm.ltpprz_ecef_accel.y,fdm.ltpprz_ecef_accel.z);
+	printf("%f,%f,%f,", fdm.ltpprz_ecef_accel.z, fdm.ltpprz_ecef_accel.y,
+			fdm.ltpprz_ecef_accel.z);
 #endif
 
-  /* llh */
-  llh_from_jsbsim(&fdm.lla_pos, propagate);
+	/* llh */
+	llh_from_jsbsim(&fdm.lla_pos, propagate);
+
+	//for debug
+	lla_from_jsbsim_geodetic(&fdm.lla_pos_geod, propagate);
+	lla_from_jsbsim_geocentric(&fdm.lla_pos_geoc, propagate);
+	lla_of_ecef_d(&fdm.lla_pos_pprz, &fdm.ecef_pos);
+	fdm.agl = MetersOfFeet(propagate->GetDistanceAGL());
+
+#if DEBUG_NPS_JSBSIM
+	printf("%f,", fdm.agl);
+	printf("%f,%f,%f,", fdm.lla_pos_pprz.lat, fdm.lla_pos_pprz.lon,
+			fdm.lla_pos_pprz.alt);
+#endif
 
-  //for debug
-  lla_from_jsbsim_geodetic(&fdm.lla_pos_geod, propagate);
-  lla_from_jsbsim_geocentric(&fdm.lla_pos_geoc, propagate);
-  lla_of_ecef_d(&fdm.lla_pos_pprz, &fdm.ecef_pos);
-  fdm.agl = MetersOfFeet(propagate->GetDistanceAGL());
+	/*
+	 * attitude
+	 */
+	const FGQuaternion jsb_quat = propagate->GetQuaternion();
+	jsbsimquat_to_quat(&fdm.ltp_to_body_quat, &jsb_quat);
+	/* convert to eulers */
+	DOUBLE_EULERS_OF_QUAT(fdm.ltp_to_body_eulers, fdm.ltp_to_body_quat);
+	/* the "false" pprz lpt */
+	/* FIXME: use jsbsim ltp for now */
+	EULERS_COPY(fdm.ltpprz_to_body_eulers, fdm.ltp_to_body_eulers);
+	QUAT_COPY(fdm.ltpprz_to_body_quat, fdm.ltp_to_body_quat);
+
+	/*
+	 * rotational speed and accelerations
+	 */
+	jsbsimvec_to_rate(&fdm.body_ecef_rotvel, &propagate->GetPQR());
+	jsbsimvec_to_rate(&fdm.body_ecef_rotaccel, &accelerations->GetPQRdot());
 
 #if DEBUG_NPS_JSBSIM
-  printf("%f\n",fdm.agl);
+	printf("%f,%f,%f\n", fdm.body_ecef_rotvel.p, fdm.body_ecef_rotvel.q,
+			fdm.body_ecef_rotvel.r);
 #endif
 
-  /*
-   * attitude
-   */
-  const FGQuaternion jsb_quat = propagate->GetQuaternion();
-  jsbsimquat_to_quat(&fdm.ltp_to_body_quat, &jsb_quat);
-  /* convert to eulers */
-  DOUBLE_EULERS_OF_QUAT(fdm.ltp_to_body_eulers, fdm.ltp_to_body_quat);
-  /* the "false" pprz lpt */
-  /* FIXME: use jsbsim ltp for now */
-  EULERS_COPY(fdm.ltpprz_to_body_eulers, fdm.ltp_to_body_eulers);
-  QUAT_COPY(fdm.ltpprz_to_body_quat, fdm.ltp_to_body_quat);
-
-  /*
-   * rotational speed and accelerations
-   */
-  jsbsimvec_to_rate(&fdm.body_ecef_rotvel, &propagate->GetPQR());
-  jsbsimvec_to_rate(&fdm.body_ecef_rotaccel, &accelerations->GetPQRdot());
-
-
-  /*
-   * wind
-   */
-  const FGColumnVector3& fg_wind_ned = FDMExec->GetWinds()->GetTotalWindNED();
-  jsbsimvec_to_vec(&fdm.wind, &fg_wind_ned);
+	/*
+	 * wind
+	 */
+	const FGColumnVector3
+	&fg_wind_ned = FDMExec->GetWinds()->GetTotalWindNED();
+	jsbsimvec_to_vec(&fdm.wind, &fg_wind_ned);
 }
 
 /**
@@ -348,99 +385,99 @@ static void fetch_state(void) {
  */
 static void init_jsbsim(double dt) {
 
-  char buf[1024];
-  string rootdir;
-  string jsbsim_ic_name;
+	char buf[1024];
+	string rootdir;
+	string jsbsim_ic_name;
 
-  sprintf(buf,"%s/conf/simulator/jsbsim/",getenv("PAPARAZZI_HOME"));
-  rootdir = string(buf);
+	sprintf(buf, "%s/conf/simulator/jsbsim/", getenv("PAPARAZZI_HOME"));
+	rootdir = string(buf);
 
-  /* if jsbsim initial conditions are defined, use them
-   * otherwise use flightplan location
-   */
+	/* if jsbsim initial conditions are defined, use them
+	 * otherwise use flightplan location
+	 */
 #ifdef NPS_JSBSIM_INIT
-  jsbsim_ic_name = NPS_JSBSIM_INIT;
+	jsbsim_ic_name = NPS_JSBSIM_INIT;
 #endif
 
-  FDMExec = new FGFDMExec();
+	FDMExec = new
+	FGFDMExec();
 
-  FDMExec->Setsim_time(0.);
-  FDMExec->Setdt(dt);
+	FDMExec->Setsim_time(0.);
+	FDMExec->Setdt(dt);
 
-  FDMExec->DisableOutput();
-  FDMExec->SetDebugLevel(0); // No DEBUG messages
+	FDMExec->DisableOutput();
+	FDMExec->SetDebugLevel(0); // No DEBUG messages
 
-  if ( ! FDMExec->LoadModel( rootdir + "aircraft",
-                             rootdir + "engine",
-                             rootdir + "systems",
-                             NPS_JSBSIM_MODEL,
-                             false)){
+	if (!FDMExec->LoadModel(rootdir + "aircraft", rootdir + "engine",
+			rootdir + "systems",
+			NPS_JSBSIM_MODEL, false)) {
 #ifdef DEBUG
-    cerr << "  JSBSim could not be started" << endl << endl;
+		cerr << "  JSBSim could not be started" << endl << endl;
 #endif
-    delete FDMExec;
-    exit(-1);
-  }
+		delete FDMExec;
+		exit(-1);
+	}
 
-  //initRunning for all engines
-  FDMExec->GetPropulsion()->InitRunning(-1);
+	//initRunning for all engines
+	FDMExec->GetPropulsion()->InitRunning(-1);
 
-  JSBSim::FGInitialCondition *IC = FDMExec->GetIC();
-  if(!jsbsim_ic_name.empty()) {
-    if ( ! IC->Load(jsbsim_ic_name)) {
+	JSBSim
+	::FGInitialCondition *IC = FDMExec->GetIC();
+	if (!jsbsim_ic_name.empty()) {
+		if (!IC->Load(jsbsim_ic_name)) {
 #ifdef DEBUG
-      cerr << "Initialization unsuccessful" << endl;
+			cerr << "Initialization unsuccessful" << endl;
 #endif
-      delete FDMExec;
-      exit(-1);
-    }
-  }
-  else {
-    // FGInitialCondition::SetAltitudeASLFtIC
-    // requires this function to be called
-    // before itself
-    IC->SetVgroundFpsIC(0.);
-
-    // Use flight plan initial conditions
-    // convert geodetic lat from flight plan to geocentric
-    double gd_lat = RadOfDeg(NAV_LAT0 / 1e7);
-    double gc_lat = gc_of_gd_lat_d(gd_lat, GROUND_ALT);
-    IC->SetLatitudeDegIC(DegOfRad(gc_lat));
-    IC->SetLongitudeDegIC(NAV_LON0 / 1e7);
-
-
-    IC->SetAltitudeASLFtIC(FeetOfMeters(GROUND_ALT + 2.0));
-    IC->SetTerrainElevationFtIC(FeetOfMeters(GROUND_ALT));
-    IC->SetPsiDegIC(QFU);
-    IC->SetVgroundFpsIC(0.);
-
-    //initRunning for all engines
-    FDMExec->GetPropulsion()->InitRunning(-1);
-    if (!FDMExec->RunIC()) {
-      cerr << "Initialization from flight plan unsuccessful" << endl;
-      exit(-1);
-    }
-
-    // compute offset between geocentric and geodetic ecef
-    struct LlaCoor_d lla0 = { RadOfDeg(NAV_LON0 / 1e7), gd_lat, (double)(NAV_ALT0+NAV_MSL0)/1000. };
-    ecef_of_lla_d(&offset, &lla0);
-    struct EcefCoor_d ecef0 = {
-      MetersOfFeet(FDMExec->GetPropagate()->GetLocation().Entry(1)),
-      MetersOfFeet(FDMExec->GetPropagate()->GetLocation().Entry(2)),
-      MetersOfFeet(FDMExec->GetPropagate()->GetLocation().Entry(3))
-    };
-    VECT3_DIFF(offset, offset, ecef0);
-  }
-
-  // calculate vehicle max radius in m
-  vehicle_radius_max = 0.01; // specify not 0.0 in case no gear
-  int num_gear = FDMExec->GetGroundReactions()->GetNumGearUnits();
-  int i;
-  for(i = 0; i < num_gear; i++) {
-    FGColumnVector3 gear_location = FDMExec->GetGroundReactions()->GetGearUnit(i)->GetBodyLocation();
-    double radius = MetersOfFeet(gear_location.Magnitude());
-    if (radius > vehicle_radius_max) vehicle_radius_max = radius;
-  }
+			delete FDMExec;
+			exit(-1);
+		}
+	} else {
+		// FGInitialCondition::SetAltitudeASLFtIC
+		// requires this function to be called
+		// before itself
+		IC->SetVgroundFpsIC(0.);
+
+		// Use flight plan initial conditions
+		// convert geodetic lat from flight plan to geocentric
+		double gd_lat = RadOfDeg(NAV_LAT0 / 1e7);
+		double gc_lat = gc_of_gd_lat_d(gd_lat, GROUND_ALT);
+		IC->SetLatitudeDegIC(DegOfRad(gc_lat));
+		IC->SetLongitudeDegIC(NAV_LON0 / 1e7);
+
+		IC->SetAltitudeASLFtIC(FeetOfMeters(GROUND_ALT + 2.0));
+		IC->SetTerrainElevationFtIC(FeetOfMeters(GROUND_ALT));
+		IC->SetPsiDegIC(QFU);
+		IC->SetVgroundFpsIC(0.);
+
+		//initRunning for all engines
+		FDMExec->GetPropulsion()->InitRunning(-1);
+		if (!FDMExec->RunIC()) {
+			cerr << "Initialization from flight plan unsuccessful" << endl;
+			exit(-1);
+		}
+
+		// compute offset between geocentric and geodetic ecef
+		struct LlaCoor_d lla0 = { RadOfDeg(NAV_LON0 / 1e7), gd_lat,
+				(double) (NAV_ALT0 + NAV_MSL0) / 1000. };
+		ecef_of_lla_d(&offset, &lla0);
+		struct EcefCoor_d ecef0 = { MetersOfFeet(
+				FDMExec->GetPropagate()->GetLocation().Entry(1)), MetersOfFeet(
+				FDMExec->GetPropagate()->GetLocation().Entry(2)), MetersOfFeet(
+				FDMExec->GetPropagate()->GetLocation().Entry(3)) };
+		VECT3_DIFF(offset, offset, ecef0);
+	}
+
+	// calculate vehicle max radius in m
+	vehicle_radius_max = 0.01; // specify not 0.0 in case no gear
+	int num_gear = FDMExec->GetGroundReactions()->GetNumGearUnits();
+	int i;
+	for (i = 0; i < num_gear; i++) {
+		FGColumnVector3 gear_location =
+				FDMExec->GetGroundReactions()->GetGearUnit(i)->GetBodyLocation();
+		double radius = MetersOfFeet(gear_location.Magnitude());
+		if (radius > vehicle_radius_max)
+			vehicle_radius_max = radius;
+	}
 
 }
 
@@ -452,29 +489,29 @@ static void init_jsbsim(double dt) {
  */
 static void init_ltp(void) {
 
-  FGPropagate* propagate = FDMExec->GetPropagate();
+	FGPropagate* propagate = FDMExec->GetPropagate();
 
-  jsbsimloc_to_loc(&fdm.ecef_pos,&propagate->GetLocation());
-  ltp_def_from_ecef_d(&ltpdef,&fdm.ecef_pos);
+	jsbsimloc_to_loc(&fdm.ecef_pos, &propagate->GetLocation());
+	ltp_def_from_ecef_d(&ltpdef, &fdm.ecef_pos);
 
-  fdm.ltp_g.x = 0.;
-  fdm.ltp_g.y = 0.;
-  fdm.ltp_g.z = 9.81;
+	fdm.ltp_g.x = 0.;
+	fdm.ltp_g.y = 0.;
+	fdm.ltp_g.z = 9.81;
 
 #ifdef AHRS_H_X
 #pragma message "Using magnetic field as defined in airframe file (AHRS section)."
-  fdm.ltp_h.x = AHRS_H_X;
-  fdm.ltp_h.y = AHRS_H_Y;
-  fdm.ltp_h.z = AHRS_H_Z;
+	fdm.ltp_h.x = AHRS_H_X;
+	fdm.ltp_h.y = AHRS_H_Y;
+	fdm.ltp_h.z = AHRS_H_Z;
 #elif defined INS_H_X
 #pragma message "Using magnetic field as defined in airframe file (INS section)."
-  fdm.ltp_h.x = INS_H_X;
-  fdm.ltp_h.y = INS_H_Y;
-  fdm.ltp_h.z = INS_H_Z;
+	fdm.ltp_h.x = INS_H_X;
+	fdm.ltp_h.y = INS_H_Y;
+	fdm.ltp_h.z = INS_H_Z;
 #else
-  fdm.ltp_h.x = 0.4912;
-  fdm.ltp_h.y = 0.1225;
-  fdm.ltp_h.z = 0.8624;
+	fdm.ltp_h.x = 0.4912;
+	fdm.ltp_h.y = 0.1225;
+	fdm.ltp_h.z = 0.8624;
 #endif
 
 }
@@ -487,13 +524,14 @@ static void init_ltp(void) {
  * @param fdm_location Pointer to EcefCoor_d struct
  * @param jsb_location Pointer to FGLocation struct
  */
-static void jsbsimloc_to_loc(EcefCoor_d* fdm_location, const FGLocation* jsb_location){
+static void jsbsimloc_to_loc(EcefCoor_d* fdm_location,
+		const FGLocation* jsb_location) {
 
-  fdm_location->x = MetersOfFeet(jsb_location->Entry(1));
-  fdm_location->y = MetersOfFeet(jsb_location->Entry(2));
-  fdm_location->z = MetersOfFeet(jsb_location->Entry(3));
+	fdm_location->x = MetersOfFeet(jsb_location->Entry(1));
+	fdm_location->y = MetersOfFeet(jsb_location->Entry(2));
+	fdm_location->z = MetersOfFeet(jsb_location->Entry(3));
 
-  VECT3_ADD(*fdm_location, offset);
+	VECT3_ADD(*fdm_location, offset);
 }
 
 /**
@@ -504,11 +542,12 @@ static void jsbsimloc_to_loc(EcefCoor_d* fdm_location, const FGLocation* jsb_loc
  * @param fdm_vector    Pointer to DoubleVect3 struct
  * @param jsb_vector    Pointer to FGColumnVector3 struct
  */
-static void jsbsimvec_to_vec(DoubleVect3* fdm_vector, const FGColumnVector3* jsb_vector) {
+static void jsbsimvec_to_vec(DoubleVect3* fdm_vector,
+		const FGColumnVector3* jsb_vector) {
 
-  fdm_vector->x = MetersOfFeet(jsb_vector->Entry(1));
-  fdm_vector->y = MetersOfFeet(jsb_vector->Entry(2));
-  fdm_vector->z = MetersOfFeet(jsb_vector->Entry(3));
+	fdm_vector->x = MetersOfFeet(jsb_vector->Entry(1));
+	fdm_vector->y = MetersOfFeet(jsb_vector->Entry(2));
+	fdm_vector->z = MetersOfFeet(jsb_vector->Entry(3));
 
 }
 
@@ -518,12 +557,13 @@ static void jsbsimvec_to_vec(DoubleVect3* fdm_vector, const FGColumnVector3* jsb
  * @param fdm_quat    Pointer to DoubleQuat struct
  * @param jsb_quat    Pointer to FGQuaternion struct
  */
-static void jsbsimquat_to_quat(DoubleQuat* fdm_quat, const FGQuaternion* jsb_quat){
+static void jsbsimquat_to_quat(DoubleQuat* fdm_quat,
+		const FGQuaternion* jsb_quat) {
 
-  fdm_quat->qi = jsb_quat->Entry(1);
-  fdm_quat->qx = jsb_quat->Entry(2);
-  fdm_quat->qy = jsb_quat->Entry(3);
-  fdm_quat->qz = jsb_quat->Entry(4);
+	fdm_quat->qi = jsb_quat->Entry(1);
+	fdm_quat->qx = jsb_quat->Entry(2);
+	fdm_quat->qy = jsb_quat->Entry(3);
+	fdm_quat->qz = jsb_quat->Entry(4);
 
 }
 
@@ -533,11 +573,12 @@ static void jsbsimquat_to_quat(DoubleQuat* fdm_quat, const FGQuaternion* jsb_qua
  * @param fdm_rate    Pointer to DoubleRates struct
  * @param jsb_vector  Pointer to FGColumnVector3 struct
  */
-static void jsbsimvec_to_rate(DoubleRates* fdm_rate, const FGColumnVector3* jsb_vector) {
+static void jsbsimvec_to_rate(DoubleRates* fdm_rate,
+		const FGColumnVector3* jsb_vector) {
 
-  fdm_rate->p = jsb_vector->Entry(1);
-  fdm_rate->q = jsb_vector->Entry(2);
-  fdm_rate->r = jsb_vector->Entry(3);
+	fdm_rate->p = jsb_vector->Entry(1);
+	fdm_rate->q = jsb_vector->Entry(2);
+	fdm_rate->r = jsb_vector->Entry(3);
 
 }
 
@@ -551,12 +592,12 @@ static void jsbsimvec_to_rate(DoubleRates* fdm_rate, const FGColumnVector3* jsb_
  */
 void llh_from_jsbsim(LlaCoor_d* fdm_lla, FGPropagate* propagate) {
 
-  fdm_lla->lat = propagate->GetGeodLatitudeRad();
-  fdm_lla->lon = propagate->GetLongitude();
-  fdm_lla->alt = propagate->GetAltitudeASLmeters();
-  //printf("geodetic alt: %f\n", MetersOfFeet(propagate->GetGeodeticAltitude()));
-  //printf("ground alt: %f\n", MetersOfFeet(propagate->GetDistanceAGL()));
-  //printf("ASL alt: %f\n", propagate->GetAltitudeASLmeters());
+	fdm_lla->lat = propagate->GetGeodLatitudeRad();
+	fdm_lla->lon = propagate->GetLongitude();
+	fdm_lla->alt = propagate->GetAltitudeASLmeters();
+	//printf("geodetic alt: %f\n", MetersOfFeet(propagate->GetGeodeticAltitude()));
+	//printf("ground alt: %f\n", MetersOfFeet(propagate->GetDistanceAGL()));
+	//printf("ASL alt: %f\n", propagate->GetAltitudeASLmeters());
 
 }
 
@@ -570,9 +611,9 @@ void llh_from_jsbsim(LlaCoor_d* fdm_lla, FGPropagate* propagate) {
  */
 void lla_from_jsbsim_geocentric(LlaCoor_d* fdm_lla, FGPropagate* propagate) {
 
-  fdm_lla->lat = propagate->GetLatitude();
-  fdm_lla->lon = propagate->GetLongitude();
-  fdm_lla->alt = MetersOfFeet(propagate->GetRadius());
+	fdm_lla->lat = propagate->GetLatitude();
+	fdm_lla->lon = propagate->GetLongitude();
+	fdm_lla->alt = MetersOfFeet(propagate->GetRadius());
 
 }
 
@@ -586,16 +627,16 @@ void lla_from_jsbsim_geocentric(LlaCoor_d* fdm_lla, FGPropagate* propagate) {
  */
 void lla_from_jsbsim_geodetic(LlaCoor_d* fdm_lla, FGPropagate* propagate) {
 
-  fdm_lla->lat = propagate->GetGeodLatitudeRad();
-  fdm_lla->lon = propagate->GetLongitude();
-  fdm_lla->alt = MetersOfFeet(propagate->GetGeodeticAltitude());
+	fdm_lla->lat = propagate->GetGeodLatitudeRad();
+	fdm_lla->lon = propagate->GetLongitude();
+	fdm_lla->alt = MetersOfFeet(propagate->GetGeodeticAltitude());
 
 }
 
 #ifdef __APPLE__
 /* Why isn't this there when we include math.h (on osx with clang)? */
 /// Check if a double is NaN.
-static int isnan(double f) { return (f != f); }
+static int isnan(double f) {return (f != f);}
 #endif
 
 /**
@@ -606,73 +647,166 @@ static int isnan(double f) { return (f != f); }
  * @return Count of new NaNs. 0 for no new NaNs.
  */
 static int check_for_nan(void) {
-  int orig_nan_count = fdm.nan_count;
-  /* Check all elements for nans */
-  if (isnan(fdm.ecef_pos.x)) fdm.nan_count++;
-  if (isnan(fdm.ecef_pos.y)) fdm.nan_count++;
-  if (isnan(fdm.ecef_pos.z)) fdm.nan_count++;
-  if (isnan(fdm.ltpprz_pos.x)) fdm.nan_count++;
-  if (isnan(fdm.ltpprz_pos.y)) fdm.nan_count++;
-  if (isnan(fdm.ltpprz_pos.z)) fdm.nan_count++;
-  if (isnan(fdm.lla_pos.lon)) fdm.nan_count++;
-  if (isnan(fdm.lla_pos.lat)) fdm.nan_count++;
-  if (isnan(fdm.lla_pos.alt)) fdm.nan_count++;
-  if (isnan(fdm.hmsl)) fdm.nan_count++;
-  // Skip debugging elements
-  if (isnan(fdm.ecef_ecef_vel.x)) fdm.nan_count++;
-  if (isnan(fdm.ecef_ecef_vel.y)) fdm.nan_count++;
-  if (isnan(fdm.ecef_ecef_vel.z)) fdm.nan_count++;
-  if (isnan(fdm.ecef_ecef_accel.x)) fdm.nan_count++;
-  if (isnan(fdm.ecef_ecef_accel.y)) fdm.nan_count++;
-  if (isnan(fdm.ecef_ecef_accel.z)) fdm.nan_count++;
-  if (isnan(fdm.body_ecef_vel.x)) fdm.nan_count++;
-  if (isnan(fdm.body_ecef_vel.y)) fdm.nan_count++;
-  if (isnan(fdm.body_ecef_vel.z)) fdm.nan_count++;
-  if (isnan(fdm.body_ecef_accel.x)) fdm.nan_count++;
-  if (isnan(fdm.body_ecef_accel.y)) fdm.nan_count++;
-  if (isnan(fdm.body_ecef_accel.z)) fdm.nan_count++;
-  if (isnan(fdm.ltp_ecef_vel.x)) fdm.nan_count++;
-  if (isnan(fdm.ltp_ecef_vel.y)) fdm.nan_count++;
-  if (isnan(fdm.ltp_ecef_vel.z)) fdm.nan_count++;
-  if (isnan(fdm.ltp_ecef_accel.x)) fdm.nan_count++;
-  if (isnan(fdm.ltp_ecef_accel.y)) fdm.nan_count++;
-  if (isnan(fdm.ltp_ecef_accel.z)) fdm.nan_count++;
-  if (isnan(fdm.ltpprz_ecef_vel.x)) fdm.nan_count++;
-  if (isnan(fdm.ltpprz_ecef_vel.y)) fdm.nan_count++;
-  if (isnan(fdm.ltpprz_ecef_vel.z)) fdm.nan_count++;
-  if (isnan(fdm.ltpprz_ecef_accel.x)) fdm.nan_count++;
-  if (isnan(fdm.ltpprz_ecef_accel.y)) fdm.nan_count++;
-  if (isnan(fdm.ltpprz_ecef_accel.z)) fdm.nan_count++;
-  if (isnan(fdm.ecef_to_body_quat.qi)) fdm.nan_count++;
-  if (isnan(fdm.ecef_to_body_quat.qx)) fdm.nan_count++;
-  if (isnan(fdm.ecef_to_body_quat.qy)) fdm.nan_count++;
-  if (isnan(fdm.ecef_to_body_quat.qz)) fdm.nan_count++;
-  if (isnan(fdm.ltp_to_body_quat.qi)) fdm.nan_count++;
-  if (isnan(fdm.ltp_to_body_quat.qx)) fdm.nan_count++;
-  if (isnan(fdm.ltp_to_body_quat.qy)) fdm.nan_count++;
-  if (isnan(fdm.ltp_to_body_quat.qz)) fdm.nan_count++;
-  if (isnan(fdm.ltp_to_body_eulers.phi)) fdm.nan_count++;
-  if (isnan(fdm.ltp_to_body_eulers.theta)) fdm.nan_count++;
-  if (isnan(fdm.ltp_to_body_eulers.psi)) fdm.nan_count++;
-  if (isnan(fdm.ltpprz_to_body_quat.qi)) fdm.nan_count++;
-  if (isnan(fdm.ltpprz_to_body_quat.qx)) fdm.nan_count++;
-  if (isnan(fdm.ltpprz_to_body_quat.qy)) fdm.nan_count++;
-  if (isnan(fdm.ltpprz_to_body_quat.qz)) fdm.nan_count++;
-  if (isnan(fdm.ltpprz_to_body_eulers.phi)) fdm.nan_count++;
-  if (isnan(fdm.ltpprz_to_body_eulers.theta)) fdm.nan_count++;
-  if (isnan(fdm.ltpprz_to_body_eulers.psi)) fdm.nan_count++;
-  if (isnan(fdm.body_ecef_rotvel.p)) fdm.nan_count++;
-  if (isnan(fdm.body_ecef_rotvel.q)) fdm.nan_count++;
-  if (isnan(fdm.body_ecef_rotvel.r)) fdm.nan_count++;
-  if (isnan(fdm.body_ecef_rotaccel.p)) fdm.nan_count++;
-  if (isnan(fdm.body_ecef_rotaccel.q)) fdm.nan_count++;
-  if (isnan(fdm.body_ecef_rotaccel.r)) fdm.nan_count++;
-  if (isnan(fdm.ltp_g.x)) fdm.nan_count++;
-  if (isnan(fdm.ltp_g.y)) fdm.nan_count++;
-  if (isnan(fdm.ltp_g.z)) fdm.nan_count++;
-  if (isnan(fdm.ltp_h.x)) fdm.nan_count++;
-  if (isnan(fdm.ltp_h.y)) fdm.nan_count++;
-  if (isnan(fdm.ltp_h.z)) fdm.nan_count++;
-
-  return (fdm.nan_count - orig_nan_count);
+	int orig_nan_count = fdm.nan_count;
+	/* Check all elements for nans */
+	if (isnan(fdm.ecef_pos.x))
+		fdm.nan_count++;
+	if (isnan(fdm.ecef_pos.y))
+		fdm.nan_count++;
+	if (isnan(fdm.ecef_pos.z))
+		fdm.nan_count++;
+	if (isnan(fdm.ltpprz_pos.x))
+		fdm.nan_count++;
+	if (isnan(fdm.ltpprz_pos.y))
+		fdm.nan_count++;
+	if (isnan(fdm.ltpprz_pos.z))
+		fdm.nan_count++;
+	if (isnan(fdm.lla_pos.lon))
+		fdm.nan_count++;
+	if (isnan(fdm.lla_pos.lat))
+		fdm.nan_count++;
+	if (isnan(fdm.lla_pos.alt))
+		fdm.nan_count++;
+	if (isnan(fdm.hmsl))
+		fdm.nan_count++;
+	// Skip debugging elements
+	if (isnan(fdm.ecef_ecef_vel.x))
+		fdm.nan_count++;
+	if (isnan(fdm.ecef_ecef_vel.y))
+		fdm.nan_count++;
+	if (isnan(fdm.ecef_ecef_vel.z))
+		fdm.nan_count++;
+	if (isnan(fdm.ecef_ecef_accel.x))
+		fdm.nan_count++;
+	if (isnan(fdm.ecef_ecef_accel.y))
+		fdm.nan_count++;
+	if (isnan(fdm.ecef_ecef_accel.z))
+		fdm.nan_count++;
+	if (isnan(fdm.body_ecef_vel.x))
+		fdm.nan_count++;
+	if (isnan(fdm.body_ecef_vel.y))
+		fdm.nan_count++;
+	if (isnan(fdm.body_ecef_vel.z))
+		fdm.nan_count++;
+	if (isnan(fdm.body_ecef_accel.x))
+		fdm.nan_count++;
+	if (isnan(fdm.body_ecef_accel.y))
+		fdm.nan_count++;
+	if (isnan(fdm.body_ecef_accel.z))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_ecef_vel.x))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_ecef_vel.y))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_ecef_vel.z))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_ecef_accel.x))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_ecef_accel.y))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_ecef_accel.z))
+		fdm.nan_count++;
+	if (isnan(fdm.ltpprz_ecef_vel.x))
+		fdm.nan_count++;
+	if (isnan(fdm.ltpprz_ecef_vel.y))
+		fdm.nan_count++;
+	if (isnan(fdm.ltpprz_ecef_vel.z))
+		fdm.nan_count++;
+	if (isnan(fdm.ltpprz_ecef_accel.x))
+		fdm.nan_count++;
+	if (isnan(fdm.ltpprz_ecef_accel.y))
+		fdm.nan_count++;
+	if (isnan(fdm.ltpprz_ecef_accel.z))
+		fdm.nan_count++;
+	if (isnan(fdm.ecef_to_body_quat.qi))
+		fdm.nan_count++;
+	if (isnan(fdm.ecef_to_body_quat.qx))
+		fdm.nan_count++;
+	if (isnan(fdm.ecef_to_body_quat.qy))
+		fdm.nan_count++;
+	if (isnan(fdm.ecef_to_body_quat.qz))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_to_body_quat.qi))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_to_body_quat.qx))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_to_body_quat.qy))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_to_body_quat.qz))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_to_body_eulers.phi))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_to_body_eulers.theta))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_to_body_eulers.psi))
+		fdm.nan_count++;
+	if (isnan(fdm.ltpprz_to_body_quat.qi))
+		fdm.nan_count++;
+	if (isnan(fdm.ltpprz_to_body_quat.qx))
+		fdm.nan_count++;
+	if (isnan(fdm.ltpprz_to_body_quat.qy))
+		fdm.nan_count++;
+	if (isnan(fdm.ltpprz_to_body_quat.qz))
+		fdm.nan_count++;
+	if (isnan(fdm.ltpprz_to_body_eulers.phi))
+		fdm.nan_count++;
+	if (isnan(fdm.ltpprz_to_body_eulers.theta))
+		fdm.nan_count++;
+	if (isnan(fdm.ltpprz_to_body_eulers.psi))
+		fdm.nan_count++;
+	if (isnan(fdm.body_ecef_rotvel.p))
+		fdm.nan_count++;
+	if (isnan(fdm.body_ecef_rotvel.q))
+		fdm.nan_count++;
+	if (isnan(fdm.body_ecef_rotvel.r))
+		fdm.nan_count++;
+	if (isnan(fdm.body_ecef_rotaccel.p))
+		fdm.nan_count++;
+	if (isnan(fdm.body_ecef_rotaccel.q))
+		fdm.nan_count++;
+	if (isnan(fdm.body_ecef_rotaccel.r))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_g.x))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_g.y))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_g.z))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_h.x))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_h.y))
+		fdm.nan_count++;
+	if (isnan(fdm.ltp_h.z))
+		fdm.nan_count++;
+
+	return (fdm.nan_count - orig_nan_count);
+}
+
+//We are now able to pull out data directly from the simulator
+
+double get_value(const char* name) {
+	return FDMExec->GetPropertyManager()->GetNode(name)->getDoubleValue();
+}
+
+void nps_fdm_remote_position(double* ptr) {
+
+#define FT2M 0.3048
+	*ptr++ = get_value("position/lat-gc-rad");
+	*ptr++ = get_value("position/long-gc-rad");
+	*ptr++ = get_value("position/h-sl-meters");
+	*ptr++ = get_value("attitude/heading-true-rad");
+	*ptr++ = get_value("velocities/vg-fps") * FT2M;
+	*ptr++ = get_value("velocities/v-down-fps") * (-FT2M);
+	*ptr++ = get_value("simulation/sim-time-sec");
+
+}
+
+void nps_fdm_remote_ir(double * ptr){
+
+	*ptr++ = get_value("attitude/roll-rad");
+	*ptr++ = get_value("attitude/pitch-rad");
+	*ptr++ = get_value("attitude/heading-true-rad");
+	*ptr++ = get_value("velocities/p-rad_sec");
+	*ptr++ = get_value("velocities/q-rad_sec");
+	*ptr++ = get_value("velocities/r-rad_sec");
 }
diff --git a/sw/simulator/nps/nps_ivy_common.c b/sw/simulator/nps/nps_ivy_common.c
index 4c869a2..f3528a5 100644
--- a/sw/simulator/nps/nps_ivy_common.c
+++ b/sw/simulator/nps/nps_ivy_common.c
@@ -193,4 +193,5 @@ void nps_ivy_display(void) {
              fdm.wind.x,
              fdm.wind.y,
              fdm.wind.z);
+
 }
diff --git a/sw/simulator/nps/nps_ivy_remote.c b/sw/simulator/nps/nps_ivy_remote.c
new file mode 100644
index 0000000..326e7fe
--- /dev/null
+++ b/sw/simulator/nps/nps_ivy_remote.c
@@ -0,0 +1,132 @@
+/*
+ * nps_ivy_remote.c
+ *
+ *  Created on: May 23, 2014
+ *      Author: j3
+ */
+
+#include "nps_ivy.h"
+
+#include <stdlib.h>
+#include <Ivy/ivy.h>
+
+#include "generated/airframe.h"
+#include "math/pprz_algebra_double.h"
+#include "subsystems/ins.h"
+#include "subsystems/navigation/common_nav.h"
+#include "subsystems/commands.h"
+#include "multi/potential.h"
+
+/* remote autopilot specific Datalink Ivy functions */
+void on_DL_MOVE_WP(IvyClientPtr app __attribute__ ((unused)),
+		void *user_data __attribute__ ((unused)),
+		int argc __attribute__ ((unused)), char *argv[]);
+void on_NPS_ATP_CMD(IvyClientPtr app __attribute__ ((unused)),
+		void *user_data __attribute__ ((unused)),
+		int argc __attribute__ ((unused)), char *argv[]);
+void on_COMMANDS(IvyClientPtr app __attribute__ ((unused)),
+		void *user_data __attribute__ ((unused)),
+		int argc __attribute__ ((unused)), char *argv[]);
+
+void nps_ivy_init(char* ivy_bus) {
+	/* init ivy and bind some messages common to fw and rotorcraft */
+	nps_ivy_common_init(ivy_bus);
+
+	IvyBindMsg(on_DL_MOVE_WP, NULL,
+			"^(\\S*) MOVE_WP (\\S*) (\\S*) (\\S*) (\\S*) (\\S*)");
+
+	//Get the commands from the Autopilot for this simulation
+	IvyBindMsg(on_NPS_ATP_CMD, NULL, "^NPS_ATP_CMD(.*)");
+
+	//Get the standard commands from the Autopilot for this simulation
+	IvyBindMsg(on_COMMANDS, NULL, "^\\S* COMMANDS (\\S*)");
+}
+
+//TODO use datalink parsing from fixedwing instead of doing it here explicitly
+
+#include "generated/settings.h"
+#include "dl_protocol.h"
+#include "subsystems/datalink/downlink.h"
+
+#define MOfCm(_x) (((float)(_x))/100.)
+
+void on_DL_MOVE_WP(IvyClientPtr app __attribute__ ((unused)),
+		void *user_data __attribute__ ((unused)),
+		int argc __attribute__ ((unused)), char *argv[]) {
+
+	if (atoi(argv[2]) == AC_ID) {
+		uint8_t wp_id = atoi(argv[1]);
+		float a = MOfCm(atoi(argv[5]));
+
+		/* Computes from (lat, long) in the referenced UTM zone */
+		struct LlaCoor_f lla;
+		lla.lat = RadOfDeg((float )(atoi(argv[3]) / 1e7));
+		lla.lon = RadOfDeg((float )(atoi(argv[4]) / 1e7));
+		//printf("move wp id=%d lat=%f lon=%f alt=%f\n", wp_id, lla.lat, lla.lon, a);
+		struct UtmCoor_f utm;
+		utm.zone = nav_utm_zone0;
+		utm_of_lla_f(&utm, &lla);
+		nav_move_waypoint(wp_id, utm.east, utm.north, a);
+
+		/* Waypoint range is limited. Computes the UTM pos back from the relative
+		 coordinates */
+		utm.east = waypoints[wp_id].x + nav_utm_east0;
+		utm.north = waypoints[wp_id].y + nav_utm_north0;
+		DOWNLINK_SEND_WP_MOVED(DefaultChannel, DefaultDevice, &wp_id, &utm.east,
+				&utm.north, &a, &nav_utm_zone0);
+		printf("move wp id=%d east=%f north=%f zone=%i alt=%f\n", wp_id,
+				utm.east, utm.north, utm.zone, a);
+	}
+}
+
+/**
+ * Callback function for ivybus to handle the autopilot command messages from the remote simulation
+ */
+void on_NPS_ATP_CMD(IvyClientPtr app __attribute__ ((unused)),
+		void *user_data __attribute__ ((unused)),
+		int argc __attribute__ ((unused)), char *argv[]) {
+
+	const char* arg = (argc < 1) ? ":::" : argv[0];
+	const char* arg2 = (argc < 2) ? "!!!" : argv[1];
+	const char* arg3 = (argc < 3) ? "???" : argv[2];
+
+	printf("on_NPS_ATP_CMD message is %s %s %s \n", arg, arg2, arg3);
+
+	//TODO Parse the message here and stuff into  commands[] array.
+	//This will then get processed in the autopilot code when it is called
+
+}
+
+/**
+ * Callback function for ivybus to handle the autopilot command messages from the remote simulation
+ */
+void on_COMMANDS(IvyClientPtr app __attribute__ ((unused)),
+		void *user_data __attribute__ ((unused)),
+		int argc __attribute__ ((unused)), char *argv[]) {
+
+	const char* arg = (argc < 1) ? ":::" : argv[0];
+	const char* arg2 = (argc < 2) ? "!!!" : argv[1];
+	const char* arg3 = (argc < 3) ? "???" : argv[2];
+
+	printf("on_COMMANDS message is %s %s %s \n", arg, arg2, arg3);
+
+	char *cp;
+
+	cp = strdupa(arg); /* Make writable copy.  */
+
+	char * pch;
+	printf("Splitting string \"%s\" into tokens:\n", cp);
+	pch = strtok(cp, " ,");
+	int i = 0;
+	while (pch != NULL) {
+		commands[i] = atoi(pch);
+		if (i > NPS_COMMANDS_NB)
+			break;
+		printf("%s\n", pch);
+		pch = strtok(NULL, " ,");
+	}
+
+	//TODO Parse the message here and stuff into  commands[] array.
+	//This will then get processed in the autopilot code when it is called
+
+}
diff --git a/sw/simulator/nps/nps_main.c b/sw/simulator/nps/nps_main.c
index a920021..90e0f25 100644
--- a/sw/simulator/nps/nps_main.c
+++ b/sw/simulator/nps/nps_main.c
@@ -169,7 +169,7 @@ static void nps_main_run_sim_step(void) {
 
 static void nps_main_display(void) {
   //  printf("display at %f\n", nps_main.display_time);
-  nps_ivy_display();
+  //nps_ivy_display();
   if (nps_main.fg_host)
     nps_flightgear_send();
 }
diff --git a/sw/simulator/nps/nps_sensor_gps.c b/sw/simulator/nps/nps_sensor_gps.c
index 1ef6abe..e96f3b4 100644
--- a/sw/simulator/nps/nps_sensor_gps.c
+++ b/sw/simulator/nps/nps_sensor_gps.c
@@ -1,6 +1,5 @@
 #include "nps_sensor_gps.h"
 
-
 #include "generated/airframe.h"
 #include "nps_fdm.h"
 #include "nps_random.h"
@@ -8,24 +7,24 @@
 #include NPS_SENSORS_PARAMS
 
 void nps_sensor_gps_init(struct NpsSensorGps* gps, double time) {
-  FLOAT_VECT3_ZERO(gps->ecef_pos);
-  FLOAT_VECT3_ZERO(gps->ecef_vel);
-  gps->hmsl = 0.0;
-  gps->pos_latency = NPS_GPS_POS_LATENCY;
-  gps->speed_latency = NPS_GPS_SPEED_LATENCY;
-  VECT3_ASSIGN(gps->pos_noise_std_dev,
-			   NPS_GPS_POS_NOISE_STD_DEV, NPS_GPS_POS_NOISE_STD_DEV, NPS_GPS_POS_NOISE_STD_DEV);
-  VECT3_ASSIGN(gps->speed_noise_std_dev,
-			   NPS_GPS_SPEED_NOISE_STD_DEV, NPS_GPS_SPEED_NOISE_STD_DEV, NPS_GPS_SPEED_NOISE_STD_DEV);
-  VECT3_ASSIGN(gps->pos_bias_initial,
-			   NPS_GPS_POS_BIAS_INITIAL_X, NPS_GPS_POS_BIAS_INITIAL_Y, NPS_GPS_POS_BIAS_INITIAL_Z);
-  VECT3_ASSIGN(gps->pos_bias_random_walk_std_dev,
-			   NPS_GPS_POS_BIAS_RANDOM_WALK_STD_DEV_X,
-			   NPS_GPS_POS_BIAS_RANDOM_WALK_STD_DEV_Y,
-			   NPS_GPS_POS_BIAS_RANDOM_WALK_STD_DEV_Z);
-  FLOAT_VECT3_ZERO(gps->pos_bias_random_walk_value);
-  gps->next_update = time;
-  gps->data_available = FALSE;
+	FLOAT_VECT3_ZERO(gps->ecef_pos);
+	FLOAT_VECT3_ZERO(gps->ecef_vel);
+	gps->hmsl = 0.0;
+	gps->pos_latency = NPS_GPS_POS_LATENCY;
+	gps->speed_latency = NPS_GPS_SPEED_LATENCY;
+	VECT3_ASSIGN(gps->pos_noise_std_dev, NPS_GPS_POS_NOISE_STD_DEV,
+			NPS_GPS_POS_NOISE_STD_DEV, NPS_GPS_POS_NOISE_STD_DEV);
+	VECT3_ASSIGN(gps->speed_noise_std_dev, NPS_GPS_SPEED_NOISE_STD_DEV,
+			NPS_GPS_SPEED_NOISE_STD_DEV, NPS_GPS_SPEED_NOISE_STD_DEV);
+	VECT3_ASSIGN(gps->pos_bias_initial, NPS_GPS_POS_BIAS_INITIAL_X,
+			NPS_GPS_POS_BIAS_INITIAL_Y, NPS_GPS_POS_BIAS_INITIAL_Z);
+	VECT3_ASSIGN(gps->pos_bias_random_walk_std_dev,
+			NPS_GPS_POS_BIAS_RANDOM_WALK_STD_DEV_X,
+			NPS_GPS_POS_BIAS_RANDOM_WALK_STD_DEV_Y,
+			NPS_GPS_POS_BIAS_RANDOM_WALK_STD_DEV_Z);
+	FLOAT_VECT3_ZERO(gps->pos_bias_random_walk_value);
+	gps->next_update = time;
+	gps->data_available = FALSE;
 }
 
 /*
@@ -37,58 +36,61 @@ void nps_sensor_gps_init(struct NpsSensorGps* gps, double time) {
 
 void nps_sensor_gps_run_step(struct NpsSensorGps* gps, double time) {
 
-  if (time < gps->next_update)
-    return;
-
-
-  /*
-   * simulate speed sensor
-   */
-  struct DoubleVect3 cur_speed_reading;
-  VECT3_COPY(cur_speed_reading, fdm.ecef_ecef_vel);
-  /* add a gaussian noise */
-  double_vect3_add_gaussian_noise(&cur_speed_reading, &gps->speed_noise_std_dev);
-
-  /* store that for later and retrieve a previously stored data */
-  UpdateSensorLatency(time, &cur_speed_reading, &gps->speed_history, gps->speed_latency, &gps->ecef_vel);
-
-
-  /*
-   * simulate position sensor
-   */
-  /* compute gps error readings */
-  struct DoubleVect3 pos_error;
-  VECT3_COPY(pos_error, gps->pos_bias_initial);
-  /* add a gaussian noise */
-  double_vect3_add_gaussian_noise(&pos_error, &gps->pos_noise_std_dev);
-  /* update random walk bias and add it to error*/
-  double_vect3_update_random_walk(&gps->pos_bias_random_walk_value, &gps->pos_bias_random_walk_std_dev, NPS_GPS_DT, 5.);
-  VECT3_ADD(pos_error, gps->pos_bias_random_walk_value);
-
-  /* add error to current pos reading */
-  struct DoubleVect3 cur_pos_reading;
-  VECT3_COPY(cur_pos_reading, fdm.ecef_pos);
-  VECT3_ADD(cur_pos_reading, pos_error);
-
-  /* store that for later and retrieve a previously stored data */
-  UpdateSensorLatency(time, &cur_pos_reading, &gps->pos_history, gps->pos_latency, &gps->ecef_pos);
-
-
-  /*
-   * simulate lla pos
-   */
-  /* convert current ecef reading to lla */
-  struct LlaCoor_d cur_lla_reading;
-  lla_of_ecef_d(&cur_lla_reading, (EcefCoor_d*) &cur_pos_reading);
-
-  /* store that for later and retrieve a previously stored data */
-  UpdateSensorLatency(time, &cur_lla_reading, &gps->lla_history, gps->pos_latency, &gps->lla_pos);
-
-  double cur_hmsl_reading = fdm.hmsl;
-  UpdateSensorLatency_Single(time, &cur_hmsl_reading, &gps->hmsl_history, gps->pos_latency, &gps->hmsl);
-
-  gps->next_update += NPS_GPS_DT;
-  gps->data_available = TRUE;
+	if (time < gps->next_update)
+		return;
+
+	/*
+	 * simulate speed sensor
+	 */
+	struct DoubleVect3 cur_speed_reading;
+	VECT3_COPY(cur_speed_reading, fdm.ecef_ecef_vel);
+	/* add a gaussian noise */
+	double_vect3_add_gaussian_noise(&cur_speed_reading,
+			&gps->speed_noise_std_dev);
+
+	/* store that for later and retrieve a previously stored data */
+	UpdateSensorLatency(time, &cur_speed_reading, &gps->speed_history,
+			gps->speed_latency, &gps->ecef_vel);
+
+	/*
+	 * simulate position sensor
+	 */
+	/* compute gps error readings */
+	struct DoubleVect3 pos_error;
+	VECT3_COPY(pos_error, gps->pos_bias_initial);
+	/* add a gaussian noise */
+	double_vect3_add_gaussian_noise(&pos_error, &gps->pos_noise_std_dev);
+	/* update random walk bias and add it to error*/
+	double_vect3_update_random_walk(&gps->pos_bias_random_walk_value,
+			&gps->pos_bias_random_walk_std_dev, NPS_GPS_DT, 5.);
+	VECT3_ADD(pos_error, gps->pos_bias_random_walk_value);
+
+	/* add error to current pos reading */
+	struct DoubleVect3 cur_pos_reading;
+	VECT3_COPY(cur_pos_reading, fdm.ecef_pos);
+	VECT3_ADD(cur_pos_reading, pos_error);
+
+	/* store that for later and retrieve a previously stored data */
+	UpdateSensorLatency(time, &cur_pos_reading, &gps->pos_history,
+			gps->pos_latency, &gps->ecef_pos);
+
+	/*
+	 * simulate lla pos
+	 */
+	/* convert current ecef reading to lla */
+	struct LlaCoor_d cur_lla_reading;
+	lla_of_ecef_d(&cur_lla_reading, (EcefCoor_d*) &cur_pos_reading);
+
+	/* store that for later and retrieve a previously stored data */
+	UpdateSensorLatency(time, &cur_lla_reading, &gps->lla_history,
+			gps->pos_latency, &gps->lla_pos);
+
+	double cur_hmsl_reading = fdm.hmsl;
+	UpdateSensorLatency_Single(time, &cur_hmsl_reading, &gps->hmsl_history,
+			gps->pos_latency, &gps->hmsl);
+
+	gps->next_update += NPS_GPS_DT;
+	gps->data_available = TRUE;
 
 }
 