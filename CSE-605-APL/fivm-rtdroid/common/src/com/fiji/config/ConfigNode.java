/*
 * ConfigNode.java
 * Copyright 2008, 2009, 2010, 2011, 2012, 2013 Fiji Systems Inc.
 * This file is part of the FIJI VM Software licensed under the FIJI PUBLIC
 * LICENSE Version 3 or any later version.  A copy of the FIJI PUBLIC LICENSE is
 * available at fivm/LEGAL and can also be found at
 * http://www.fiji-systems.com/FPL3.txt
 * 
 * By installing, reproducing, distributing, and/or using the FIJI VM Software
 * you agree to the terms of the FIJI PUBLIC LICENSE.  You may exercise the
 * rights granted under the FIJI PUBLIC LICENSE subject to the conditions and
 * restrictions stated therein.  Among other conditions and restrictions, the
 * FIJI PUBLIC LICENSE states that:
 * 
 * a. You may only make non-commercial use of the FIJI VM Software.
 * 
 * b. Any adaptation you make must be licensed under the same terms 
 * of the FIJI PUBLIC LICENSE.
 * 
 * c. You must include a copy of the FIJI PUBLIC LICENSE in every copy of any
 * file, adaptation or output code that you distribute and cause the output code
 * to provide a notice of the FIJI PUBLIC LICENSE. 
 * 
 * d. You must not impose any additional conditions.
 * 
 * e. You must not assert or imply any connection, sponsorship or endorsement by
 * the author of the FIJI VM Software
 * 
 * f. You must take no derogatory action in relation to the FIJI VM Software
 * which would be prejudicial to the FIJI VM Software author's honor or
 * reputation.
 * 
 * 
 * The FIJI VM Software is provided as-is.  FIJI SYSTEMS INC does not make any
 * representation and provides no warranty of any kind concerning the software.
 * 
 * The FIJI PUBLIC LICENSE and any rights granted therein terminate
 * automatically upon any breach by you of the terms of the FIJI PUBLIC LICENSE.
 */

package com.fiji.config;

import com.fiji.fivm.FileUtils;
import com.fiji.fivm.Detector;
import com.fiji.fivm.Settings;
import java.io.*;

public abstract class ConfigNode {
    
    File file; // original file from which I came
    
    ConfigNode parent;

    // cannot be instantiated directly
    ConfigNode() {}
    
    public ConfigNode getParent() {
        return parent;
    }
    
    public void setFile(File file) {
        this.file=file;
    }
    
    public void clearFile() {
        this.file=null;
    }
    
    public boolean hasFile() {
        return file!=null;
    }
    
    public File getFile() {
        return this.file;
    }
    
    public boolean isContextRoot() {
        return file!=null || parent==null;
    }
    
    public String getContextDescription() {
        StringBuilder buf=new StringBuilder();
        makeContextPre(buf);
        buf.append(getContextInnards());
        makeContextPost(buf);
        if (hasFile()) {
            buf.append(" in ");
            buf.append(file);
        }
        return buf.toString();
    }
    
    public String toString() {
        throw new Error();
    }
    
    public final String toPrettyString() {
        return toPrettyString(0,0,4);
    }
    
    public int hashCode() {
        return toString().hashCode();
    }
    
    public boolean equals(Object other_) {
        if (this==other_) return true;
        if (!(other_ instanceof ConfigNode)) return false;
        return toString().equals(((ConfigNode)other_).toString());
    }
    
    public void save(File file,String msg) throws IOException {
        OutputStreamWriter flout=new OutputStreamWriter(
            new FileOutputStream(file),"UTF-8");
        try {
            flout.write("# "+msg+lineSeparator);
            flout.write(toPrettyString());
        } finally {
            flout.close();
        }
    }
    
    public void save(File file) throws IOException {
        save(file,"generated by com.fiji.config.ConfigNode");
    }
    
    public static ConfigNode toNode(Object obj) {
        if (obj instanceof ConfigNode) {
            return (ConfigNode)obj;
        } else {
            try {
                return new ConfigAtomNode(obj);
            } catch (IllegalArgumentException e) {
                // uhhh... why is this here?
                throw new IllegalArgumentException(
                    "Cannot convert "+obj+" to a configuration node; "+obj.getClass()+
                    " is not an acceptable type");
            }
        }
    }
    
    public final ConfigAtomNode asAtom() {
        if (this instanceof ConfigAtomNode) {
            return (ConfigAtomNode)this;
        } else {
            throw new UnexpectedConfigNodeException(
                "Expected an atom but got "+nodeTypeNameArticle()+" "+nodeTypeName()+
                " at "+getContextDescription());
        }
    }
    
    public final ConfigListNode asList() {
        if (this instanceof ConfigListNode) {
            return (ConfigListNode)this;
        } else {
            throw new UnexpectedConfigNodeException(
                "Expected a list but got "+nodeTypeNameArticle()+" "+nodeTypeName()+
                " at "+getContextDescription());
        }
    }
    
    public final ConfigMapNode asMap() {
        if (this instanceof ConfigMapNode) {
            return (ConfigMapNode)this;
        } else {
            throw new UnexpectedConfigNodeException(
                "Expected a map but got "+nodeTypeNameArticle()+" "+nodeTypeName()+
                " at "+getContextDescription());
        }
    }
    
    public static ConfigNode parse(String data) {
        Parser p=new Parser(data,1,null);
        return p.parse();
    }
    
    public static ConfigNode parse(File flnm) throws IOException {
        Parser p=new Parser(new String(FileUtils.readCompletely(flnm),"UTF-8"),
                            1,flnm);
        return p.parse();
    }
    
    // this epic madness is due to the fact that this code gets called super early
    // in the VM initialization cycle.
    static class ResizableByteArray {
        static final int defaultSize=64;
        
        byte[] payload;
        int next;
        
        ResizableByteArray() {
            payload=new byte[defaultSize];
        }
        
        void upsize() {
            byte[] newPayload=new byte[payload.length<<1];
            System.arraycopy(payload,0,
                             newPayload,0,
                             payload.length);
            payload=newPayload;
        }
        
        void write(int b) {
            if (next==payload.length) {
                upsize();
            }
            payload[next++]=(byte)b;
        }
        
        String convertToString() {
            // FIXME code duplication with ASM
            char[] buf=new char[next];
            for (;;) {
                int index=-1;
                int endIndex=-1;
                try {
                    try {
                        index = 0;
                        endIndex = this.next;
                        byte[] b = payload;
                        int strLen = 0;
                        int c, d, e;
                        while (index < endIndex) {
                            c = b[index++] & 0xFF;
                            switch (c >> 4) {
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                                // 0xxxxxxx
                                buf[strLen++] = (char) c;
                                break;
                            case 12:
                            case 13:
                                // 110x xxxx 10xx xxxx
                                d = b[index++];
                                buf[strLen++] = (char) (((c & 0x1F) << 6) | (d & 0x3F));
                                break;
                            default:
                                // 1110 xxxx 10xx xxxx 10xx xxxx
                                d = b[index++];
                                e = b[index++];
                                buf[strLen++] = (char) (((c & 0x0F) << 12)
                                                        | ((d & 0x3F) << 6) | (e & 0x3F));
                                break;
                            }
                        }
                        return new String(buf, 0, strLen);
                    } catch (ArrayIndexOutOfBoundsException e) {
                        // will this ever happen?  who knows, who cares...
                        try {
                            buf=new char[buf.length<<1];
                        } catch (Throwable e2) {
                            throw new Error("Could not reallocate buffer due to "+e2+" after getting an ArrayIndexOutOfBoundsException",e);
                        }
                    }
                } catch (Throwable e) {
                    throw new Error("Could not convert to string bytes to string");
                }
            }
        }
    }
    
    static class Parser {
        char[] data;
        int idx;
        int line;
        File flnm;
        
        Parser(String str,
               int line,
               File flnm) {
            data=str.toCharArray();
            idx=0;
            this.line=line;
            this.flnm=flnm;
        }
        
        ConfigNode parse() {
            try {
                proceedThroughWS();
                ConfigNode result=parseNode();
                parseWS();
                result.setFile(flnm);
                return result;
            } catch (ConfigParseException e) {
                throw e;
            } catch (Exception e) {
                throw new ConfigParseException(
                    "Internal error in parser",this,e);
            }
        }
        
        ConfigNode parseNode() {
            switch (data[idx]) {
            case '\"':
                return parseQuotedString();
            case '(':
                return parseList();
            case '{':
                return parseMap();
            default:
                if (isIdentifier(data[idx])) {
                    return parseIdentifier();
                } else {
                    throw new ConfigParseException("Bad token: '"+data[idx]+"'",this);
                }
            }
        }
        
        ConfigMapNode parseMap() {
            assertNotEOF();
            if (data[idx]!='{') {
                throw new ConfigParseException(
                    "Expected beginning of map but got '"+data[idx]+"'",this);
            }
            
            ConfigMapNode result=new ConfigMapNode();
            
            proceed();
            
            for (;;) {
                proceedThroughWS();
                
                if (data[idx]==',' ||
                    data[idx]==';') {
                    proceed();
                    continue;
                }
                
                if (data[idx]=='}') {
                    idx++;
                    break;
                }
                
                ConfigAtomNode key=parseString();
                
                proceedThroughWS();
                
                if (data[idx]!='=') {
                    throw new ConfigParseException(
                        "Expected '=' after key in map but got '"+data[idx]+"'",this);
                }
                
                proceed();
                proceedThroughWS();
                
                result.put(key.getString(),parseNode());
            }
            
            return result;
        }
        
        ConfigListNode parseList() {
            assertNotEOF();
            if (data[idx]!='(') {
                throw new ConfigParseException(
                    "Expected beginning of list but got '"+data[idx]+"'",this);
            }
            
            ConfigListNode result=new ConfigListNode();
            
            proceed();
            
            for (;;) {
                proceedThroughWS();
                
                if (data[idx]==',' ||
                    data[idx]==';') {
                    proceed();
                    continue;
                }
                
                if (data[idx]==')') {
                    ++idx;
                    break;
                }
                
                result.append(parseNode());
            }
            
            return result;
        }
        
        ConfigAtomNode parseString() {
            assertNotEOF();
            
            if (data[idx]=='\"') {
                return parseQuotedString();
            } else if (isIdentifier(data[idx])) {
                return parseIdentifier();
            } else {
                throw new ConfigParseException(
                    "Expected beginning of string or identifier but got '"+data[idx]+"'",
                    this);
            }
        }
        
        ConfigAtomNode parseQuotedString() {
            assertNotEOF();

            if (data[idx]!='"') {
                throw new ConfigParseException(
                    "Expected beginning of quoted string but got '"+data[idx]+
                    "'",this);
            }
            
            proceed();
            
            ResizableByteArray bout=new ResizableByteArray();
            
            for (;;) {
                boolean cont=true;
                switch (data[idx]) {
                case '"':
                    cont=false;
                    break;
                case '\n':
                case '\r':
                    throw new ConfigParseException(
                        "New-line and carriage-return not allowed in quoted strings",this);
                case '\\':
                    proceed();
                    switch (data[idx]) {
                    case 'n':
                    case 'N':
                        bout.write('\n');
                        break;
                    case 'r':
                    case 'R':
                        bout.write('\r');
                        break;
                    case 't':
                    case 'T':
                        bout.write('\t');
                        break;
                    case 'x':
                    case 'X': {
                        char hexlo,hexhi;
                        proceed();
                        hexhi=data[idx];
                        proceed();
                        hexlo=data[idx];
                        
                        if (!isxdigit(hexhi) ||
                            !isxdigit(hexlo)) {
                            throw new ConfigParseException(
                                "The \\x and \\X escape codes must be followed by "+
                                "two hex digits; but instead got '"+hexhi+hexlo+"'",
                                this);
                        }
                        
                        bout.write((fromHex(hexlo)<<0)|
                                   (fromHex(hexhi)<<4));
                        break;
                    }
                    case '0':
                    case '1':
                    case '2':
                    case '3': {
                        char octlo,octmd,octhi;
                        octhi=data[idx];
                        proceed();
                        octmd=data[idx];
                        proceed();
                        octlo=data[idx];
                        
                        if (!isodigit(octlo) ||
                            !isodigit(octmd) ||
                            !isodigit(octhi)) {
                            throw new ConfigParseException(
                                "Expected octal escape code after seeing '\\"+octhi+"', but "+
                                "instead got '"+octhi+octmd+octlo+"'",
                                this);
                        }
                        
                        bout.write((fromOct(octlo)<<0)|
                                   (fromOct(octmd)<<3)|
                                   (fromOct(octhi)<<6));
                        break;
                    }
                    // FIXME implement new-line-in-string
                    default:
                        bout.write(data[idx]);
                        break;
                    }
                    break;
                default:
                    // FIXME: should be able to handle UTF-8 in string literals
                    bout.write(data[idx]);
                    break;
                }
                if (cont) {
                    proceed();
                } else {
                    break;
                }
            }
            
            idx++;
            
            // ok ... time for nast.  the string we've been building is actually
            // an *encoded* utf-8 string.  time to decode it.
            return new ConfigAtomNode(bout.convertToString());
        }
        
        ConfigAtomNode parseIdentifier() {
            assertNotEOF();
            
            if (!isIdentifier(data[idx])) {
                throw new ConfigParseException(
                    "Expected beginning of identifier but got '"+data[idx]+
                    "'",this);
            }
            
            StringBuilder buf=new StringBuilder();
            
            while (idx!=data.length && isIdentifier(data[idx])) {
                buf.append(data[idx++]);
            }
            
            return new ConfigAtomNode(buf.toString());
        }
        
        void parseWSImpl(boolean die) {
            while (idx!=data.length) {
                switch (data[idx]) {
                case '\n':
                    ++line;
                    break;
                case ' ':
                case '\r':
                case '\t':
                    break;
                case '#':
                    do {
                        proceed();
                    } while (data[idx]!='\n');
                    ++line;
                    break;
                default:
                    if (die) {
                        throw new ConfigParseException(
                            "Expected whitespace but got '"+data[idx]+"'",this);
                    } else {
                        return;
                    }
                }
                ++idx;
            }
        }
        
        void parseWS() {
            parseWSImpl(true);
        }
        
        void proceedThroughWS() {
            parseWSImpl(false);
        }
        
        void proceed() {
            ++idx;
            assertNotEOF();
        }
        
        void assertNotEOF() {
            if (idx==data.length) {
                throw new ConfigParseException(
                    "Unexpected end-of-file",this);
            }
        }
    }
    
    // helpers and internal stuff
            
    static boolean isalnum(char c) {
        return (c>='a' && c<='z')
            || (c>='A' && c<='Z')
            || (c>='0' && c<='9');
    }
    
    static boolean isxdigit(char c) {
        return (c>='a' && c<='f')
            || (c>='A' && c<='F')
            || (c>='0' && c<='9');
    }
    
    static boolean isodigit(char c) {
        return c>='0' && c<='7';
    }
    
    static char toHex(int c) {
        return (char)(c>=10?c-10+'a':'0'+c);
    }
    
    static char toOct(int c) {
        return (char)('0'+c);
    }
    
    static int fromHex(char c) {
        if (c>='0' && c<='9') {
            return c-'0';
        } else if (c>='a' && c<='f') {
            return c-'a';
        } else {
            return c-'A';
        }
    }
    
    static int fromOct(char c) {
        return c-'0';
    }
    
    static boolean isIdentifier(char c) {
        return isalnum(c)
            || c == '_'
            || c == '$'
            || c == '-'
            || c == '/'
            || c == '.'
            || c == '+';
    }
    
    boolean forceMultiLine() {
        return false;
    }

    abstract String toPrettyShortString();
    abstract String toPrettyMultiLineString(int startIndent,
                                            int indentLevel,
                                            int indentStep);
    
    final String toPrettyString(int startIndent,
                                int indentLevel,
                                int indentStep) {
        if (forceMultiLine()) {
            return toPrettyMultiLineString(startIndent,
                                           indentLevel,
                                           indentStep);
        }
        String result=toPrettyShortString();
        if (result.length()+indentLevel + startIndent > 80) {
            return toPrettyMultiLineString(startIndent,
                                           indentLevel,
                                           indentStep);
        } else {
            return result;
        }
    }
    
    abstract String nodeTypeNameArticle();
    abstract String nodeTypeName();
    
    final void makeContextPre(StringBuilder buf) {
        if (!isContextRoot()) {
            parent.makeContextPre(buf);
            buf.append(parent.getContextPre(this));
        }
    }
    
    final void makeContextPost(StringBuilder buf) {
        if (!isContextRoot()) {
            buf.append(parent.getContextPost(this));
            parent.makeContextPost(buf);
        }
    }
    
    String getContextPre(ConfigNode forNode) {
        return "";
    }
    
    String getContextPost(ConfigNode forNode) {
        return "";
    }
    
    abstract String getContextInnards();
    
    void setParent(ConfigNode parent) {
        if (this.parent!=null) {
            throw new IllegalStateException(
                "Cannot make "+parent.getContextDescription()+" a parent of "+
                getContextDescription()+"; the latter already has a parent");
        }
        this.parent=parent;
    }
    
    void resetParent() {
        assert parent!=null;
        parent=null;
    }
    
    static String[] indentations;
    
    static {
        String manySpaces="";
        for (int i=0;i<80;++i) {
            manySpaces+=" ";
        }
        indentations=new String[manySpaces.length()+1];
        for (int i=0;i<indentations.length;++i) {
            indentations[i]=manySpaces.substring(0,i);
        }
    }
    
    static String indent(int num) {
        if (num<indentations.length) {
            return indentations[num];
        } else {
            String result=indentations[indentations.length-1];
            while (result.length()<num) {
                result+=" ";
            }
            return result;
        }
    }
    
    static String lineSeparator;
    
    static {
        // more madness to support the fact that we use this code early in the
        // VM init cycle.  yay VM init cycles.
        if (Detector.IS_FIJI) {
            if (Settings.WIN32) {
                lineSeparator="\r\n";
            } else {
                lineSeparator="\n";
            }
        } else {
            lineSeparator=System.getProperty("line.separator");
        }
    }
}

